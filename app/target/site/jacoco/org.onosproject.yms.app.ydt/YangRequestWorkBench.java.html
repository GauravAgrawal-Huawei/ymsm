<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>YangRequestWorkBench.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">onos-app-yms</a> &gt; <a href="index.source.html" class="el_package">org.onosproject.yms.app.ydt</a> &gt; <span class="el_source">YangRequestWorkBench.java</span></div><h1>YangRequestWorkBench.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2016-present Open Networking Laboratory
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.onosproject.yms.app.ydt;

import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.onosproject.yangutils.datamodel.YangList;
import org.onosproject.yangutils.datamodel.YangSchemaNode;
import org.onosproject.yangutils.datamodel.YangSchemaNodeContextInfo;
import org.onosproject.yangutils.datamodel.YangSchemaNodeIdentifier;
import org.onosproject.yangutils.datamodel.exceptions.DataModelException;
import org.onosproject.yms.app.ydt.exceptions.YdtExceptions;
import org.onosproject.yms.app.ysr.YangSchemaRegistry;
import org.onosproject.yms.ydt.YdtContext;
import org.onosproject.yms.ydt.YdtContextOperationType;
import org.onosproject.yms.ydt.YdtType;
import org.onosproject.yms.ydt.YmsOperationType;


/**
 * Represents YANG request work bench which contains all parameters for
 * request handling and methods to build and obtain YANG data tree
 * which is data (sub)instance representation, abstract of protocol.
 */
public class YangRequestWorkBench
        implements YdtExtendedBuilder {

    /**
     * Current node in YANG data tree, kept to maintain the current context in
     * YDT.
     */
    private YdtNode curNode;

    /**
     * Root node in YANG data tree, kept to maintain the root context in
     * YDT.
     */
    private YdtNode rootNode;

    /**
     * Current node in YANG data tree, kept to maintain the current context
     * in ydt application tree.
     */
    private YdtAppContext curAppNode;

    /**
     * Root node in YANG data tree, kept to maintain the root context in ydt
     * application tree.
     */
    private YdtAppContext rootAppNode;

    /**
     * Root Node Tag attribute in YANG data tree, kept to maintain the root
     * tag attributes in
     * YDT.
     * First key param of map represent tagName  name of tag attribute.
     * Second param of map represent tagValue value of tag attribute
     */
    private Map&lt;String, String&gt; rootTagAttributeMap;

    /**
     * YANG schema registry reference.
     */
    private final YangSchemaRegistry yangSchemaRegistry;

    /**
     * YMS operation type.
     */
    private final YmsOperationType ymsOperationType;

    /**
     * YDT default operation type.
     */
    private YdtContextOperationType ydtContextDefaultOpType;

    /**
     * Creates an instance of YangRequestWorkBench which is use to initialize
     * logical rootNode and and schema registry.
     *
     * @param logicalRootName      name of logical container of a protocol
     *                             which is a
     *                             holder of the complete tree
     * @param rootNamespace        namespace of logical container
     * @param operationType        type of operation done by using YANG
     *                             interface.
     * @param schemaRegistry       YMS schema registry
     * @param enableDataValidation Flag to identify validation need to be
     *                             done by YDT or not
     */
    public YangRequestWorkBench(String logicalRootName, String rootNamespace,
                                YmsOperationType operationType,
                                YangSchemaRegistry schemaRegistry,
<span class="fc" id="L110">                                boolean enableDataValidation) {</span>
        YdtNode newNode;
<span class="fc" id="L112">        YangSchemaNodeIdentifier nodeIdentifier =</span>
                new YangSchemaNodeIdentifier();
<span class="fc" id="L114">        nodeIdentifier.setName(logicalRootName);</span>
<span class="fc" id="L115">        nodeIdentifier.setNameSpace(rootNamespace);</span>
<span class="fc" id="L116">        newNode = new YdtSingleInstanceNode(nodeIdentifier);</span>
<span class="fc" id="L117">        setRootNode(newNode);</span>
<span class="fc" id="L118">        yangSchemaRegistry = schemaRegistry;</span>
<span class="fc" id="L119">        ymsOperationType = operationType;</span>

        // Set the logical root node for yang data app tree.
<span class="fc" id="L122">        rootAppNode = new DefaultYdtAppContext();</span>
<span class="fc" id="L123">        rootAppNode.setModuleNode(newNode);</span>
<span class="fc" id="L124">        setAppRootNode(rootAppNode);</span>
<span class="fc" id="L125">    }</span>

    /**
     * Set the logical root context information available in YDT node.
     *
     * @param rootNode refers to root node
     */
    private void setRootNode(YdtNode rootNode) {
        // Setting the root node
<span class="fc" id="L134">        this.rootNode = rootNode;</span>
<span class="fc" id="L135">        curNode = this.rootNode;</span>
<span class="fc" id="L136">    }</span>

    /**
     * Set the app context tree logical root node  for ydt application tree.
     *
     * @param rootAppNode refers to logical root node
     */
    private void setAppRootNode(YdtAppContext rootAppNode) {
<span class="fc" id="L144">        this.rootAppNode = rootAppNode;</span>
<span class="fc" id="L145">        curAppNode = rootAppNode;</span>
<span class="fc" id="L146">    }</span>

    /**
     * Get the app context tree root node  for ydt application tree.
     *
     * @return YdtAppContext refers to root node of ydt application tree.
     */
    public YdtAppContext getAppRootNode() {
<span class="fc" id="L154">        return rootAppNode;</span>
    }

    /**
     * Get the Data model tree for given node.
     *
     * @param nodeIdentifier Represents a identifier of YANG data tree node
     * @return YANG data tree node
     */
    private YdtNode moduleHandler(YangSchemaNodeIdentifier nodeIdentifier) {

<span class="fc" id="L165">        YangSchemaNode node = yangSchemaRegistry</span>
<span class="fc" id="L166">                .getYangSchemaNodeUsingSchemaName(nodeIdentifier.getName());</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">        if (node == null) {</span>
            // Free resources
<span class="fc" id="L169">            curNode.freeRestResources();</span>
<span class="fc" id="L170">            String errorInfo =</span>
<span class="fc" id="L171">                    &quot;Schema node with name &quot; + nodeIdentifier.getName() +</span>
                            &quot; doesn't exist.&quot;;
<span class="fc" id="L173">            throw new YdtExceptions(errorInfo);</span>
        }
<span class="fc" id="L175">        YdtNode newNode = new YdtSingleInstanceNode(nodeIdentifier);</span>
<span class="fc" id="L176">        newNode.setYangSchemaNode(node);</span>
<span class="fc" id="L177">        return newNode;</span>
    }

    @Override
    public void setRootTagAttributeMap(Map&lt;String, String&gt; attributeTag) {
<span class="fc" id="L182">        rootTagAttributeMap = attributeTag;</span>
<span class="fc" id="L183">    }</span>

    @Override
    public Map&lt;String, String&gt; getRootTagAttributeMap() {
<span class="fc" id="L187">        return rootTagAttributeMap;</span>
    }

    @Override
    public void addChild(String name, String namespace) {
<span class="fc" id="L192">        addChild(name, namespace, RequestedCardinality.UNKNOWN, null, false);</span>
<span class="fc" id="L193">    }</span>

    @Override
    public void addChild(String name, String namespace, YdtType ydtType) {
        // Checking the YdtType and processing it accordingly.
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">        if (ydtType == YdtType.MULTI_INSTANCE_NODE) {</span>
<span class="fc" id="L199">            addChild(name, namespace, RequestedCardinality.MULTI_INSTANCE, null,</span>
                     false);
        } else {
<span class="nc" id="L202">            addChild(name, namespace, RequestedCardinality.SINGLE_INSTANCE,</span>
                     null, false);
        }
<span class="fc" id="L205">    }</span>

    @Override
    public void addChild(String name, String namespace,
                         YdtContextOperationType opType) {
<span class="fc" id="L210">        addChild(name, namespace, RequestedCardinality.UNKNOWN, opType, false);</span>

<span class="fc" id="L212">    }</span>

    @Override
    public void addChild(String name, String namespace, YdtType ydtType,
                         YdtContextOperationType opType) {
        // Checking the YdtType and processing it accordingly.
<span class="nc bnc" id="L218" title="All 2 branches missed.">        if (ydtType == YdtType.MULTI_INSTANCE_NODE) {</span>
<span class="nc" id="L219">            addChild(name, namespace, RequestedCardinality.MULTI_INSTANCE,</span>
                     opType, false);
        } else {
<span class="nc" id="L222">            addChild(name, namespace, RequestedCardinality.SINGLE_INSTANCE,</span>
                     opType, false);
        }
<span class="nc" id="L225">    }</span>


    /**
     * Adds a last child to YANG data tree, this method is to be used by all
     * protocols internally which are aware or unaware of the nature
     * (single/multiple) of node.
     *
     * @param name                 name of child to be added
     * @param namespace            namespace of child to be added, if it's
     *                             null, parent's
     *                             namespace will be applied to child
     * @param requestedCardinality type of YANG data tree node operation
     * @param opType               type of requested operation over a node
     * @param isLeaf               denotes call type whether form addChild or
     *                             addLeaf
     * @return returns added ydt node in YDT tree
     */
    private YdtNode addChild(String name, String namespace,
                             RequestedCardinality requestedCardinality,
                             YdtContextOperationType opType, boolean isLeaf) {

        YdtNode childNode;
<span class="fc" id="L248">        boolean isContextSwitch = false;</span>
        YangSchemaNode yangSchemaNode;
        YangSchemaNodeContextInfo childSchemaNodeInfo;
<span class="fc" id="L251">        YangSchemaNode lastAugmentingModuleNode = null;</span>

<span class="fc" id="L253">        YangSchemaNodeIdentifier nodeIdentifier =</span>
                new YangSchemaNodeIdentifier();
<span class="fc" id="L255">        nodeIdentifier.setName(name);</span>

        // Reference for parent node operation type.
<span class="fc" id="L258">        YdtContextOperationType parentOpType =</span>
<span class="fc" id="L259">                curNode.getYdtContextOperationType();</span>

<span class="fc bfc" id="L261" title="All 2 branches covered.">        if (!isLeaf) {</span>
<span class="fc bfc" id="L262" title="All 4 branches covered.">            if ((opType != null) &amp;&amp; (parentOpType != null)) {</span>
                // Get operation type validate
<span class="fc" id="L264">                getOperationTypeValidate(parentOpType, opType);</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">            } else if (opType == null) {</span>
                /**
                 * Checking the default operation type
                 * If default operation type
                 * is not set, merge will be taken as default operation type.
                 */
<span class="pc bpc" id="L271" title="1 of 2 branches missed.">                if (ydtContextDefaultOpType != null) {</span>
<span class="nc" id="L272">                    opType = ydtContextDefaultOpType;</span>
                } else {
<span class="fc" id="L274">                    opType = YdtContextOperationType.MERGE;</span>
                }

            }
        }

        // Module/sub-module node handler.
<span class="fc bfc" id="L281" title="All 2 branches covered.">        if (curNode == rootNode) {</span>
<span class="fc" id="L282">            childNode = moduleHandler(nodeIdentifier);</span>
<span class="fc" id="L283">            nodeIdentifier</span>
<span class="fc" id="L284">                    .setNameSpace(childNode.getYangSchemaNode().getNameSpace());</span>
            /**
             * Setting context switch flag for root node
             * So when another module comes then it will help ydt to to keep
             * track whether ydtApp tree also need to
             * be traversed back to parent or not.
             */

        } else {

            // If namespace given by user null, then take namespace from parent.
<span class="fc bfc" id="L295" title="All 2 branches covered.">            if (namespace == null) {</span>
<span class="fc" id="L296">                namespace = curNode.getYangSchemaNode()</span>
<span class="fc" id="L297">                        .getYangSchemaNodeIdentifier().getNameSpace();</span>
            }

<span class="fc" id="L300">            nodeIdentifier.setNameSpace(namespace);</span>

            // Get the already exiting YDT node in YDT tree with same
            // nodeIdentifier.
<span class="fc" id="L304">            childNode = (YdtNode) curNode.getCollidingChild(nodeIdentifier);</span>

            /*
             * If colliding child doesn't exist ,
             * then query yang data model for schema for given node.
             */
<span class="fc bfc" id="L310" title="All 2 branches covered.">            if (childNode == null) {</span>

                // Get Yang Schema node context info which is having
                // YangSchemaNode + ContextSwitchedNode.
<span class="fc" id="L314">                childSchemaNodeInfo =</span>
<span class="fc" id="L315">                        curNode.getSchemaNodeContextInfo(nodeIdentifier);</span>

<span class="fc bfc" id="L317" title="All 2 branches covered.">                if (childSchemaNodeInfo.getContextSwitchedNode() != null) {</span>
<span class="fc" id="L318">                    lastAugmentingModuleNode =</span>
<span class="fc" id="L319">                            curAppNode.getAugmentingSchemaNode(nodeIdentifier,</span>
                                                               childSchemaNodeInfo);
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">                    if (lastAugmentingModuleNode != null) {</span>
<span class="nc" id="L322">                        if (curAppNode</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">                                .addYdtAppTreeSet(lastAugmentingModuleNode)) {</span>
<span class="nc" id="L324">                            isContextSwitch = true;</span>
                        }
                    }
                }
<span class="fc" id="L328">                yangSchemaNode = childSchemaNodeInfo.getSchemaNode();</span>

            } else {
                /*
                * If colliding child exist , it will be leaf-list or list
                * then take yang data node information from colliding child.
                */
<span class="fc" id="L335">                yangSchemaNode = childNode.getYangSchemaNode();</span>

<span class="fc bfc" id="L337" title="All 2 branches covered.">                if (isLeaf) {</span>
<span class="fc" id="L338">                    return childNode;</span>
                }
            }

            // Get the ydtNode of respective type.
<span class="fc" id="L343">            childNode = YdtNodeFactory.getNode(nodeIdentifier, yangSchemaNode,</span>
                                               requestedCardinality, isLeaf);
        }

        // Update node identifier.
<span class="fc" id="L348">        childNode.setNodeIdentifier(nodeIdentifier);</span>

<span class="fc bfc" id="L350" title="All 2 branches covered.">        if (!isLeaf) {</span>
            // Update operation type.
<span class="fc" id="L352">            childNode.setYdtContextOperationType(opType);</span>
        }

        // Add child.
<span class="fc" id="L356">        curNode.addChild(childNode, true);</span>

        // Update parent ydt node map.
<span class="fc" id="L359">        curNode.updateYdtMap(nodeIdentifier, childNode);</span>

        /**
         * Create entry of module node in ydt app tree.
         * And if context switch happened then add entry for same node in the
         * ydt application tree.
         */

<span class="fc bfc" id="L367" title="All 2 branches covered.">        if (isLeaf) {</span>
<span class="fc" id="L368">            opType = curNode.getYdtContextOperationType();</span>
        }

<span class="pc bpc" id="L371" title="1 of 4 branches missed.">        if ((curNode == rootNode) || (isContextSwitch)) {</span>
            // Add application context switched child in ydt App tree.
<span class="fc" id="L373">            addChildInAppTree(childNode, lastAugmentingModuleNode, opType,</span>
                              isContextSwitch);
        }

        // Update app tree module node operation.
<span class="fc" id="L378">        curAppNode.getApplicationParent().updateAppOperationType(opType);</span>

        // Updating the delete operation list in app tree.
<span class="fc" id="L381">        updateDeleteOperationList(childNode);</span>

        // Updating the curNode.
<span class="fc" id="L384">        curNode = childNode;</span>

<span class="fc" id="L386">        return childNode;</span>
    }

    /**
     * Add the given ydt node (with operation type delete/remove)in delete list.
     *
     * @param childNode ydt node
     */
    private void updateDeleteOperationList(YdtNode childNode) {
<span class="fc bfc" id="L395" title="All 2 branches covered.">        if ((childNode.getYdtContextOperationType() ==</span>
                YdtContextOperationType.DELETE) ||
<span class="pc bpc" id="L397" title="1 of 2 branches missed.">                (childNode.getYdtContextOperationType() ==</span>
                        YdtContextOperationType.REMOVE)) {

<span class="fc" id="L400">            List&lt;YdtContext&gt; deleteNodeList =</span>
<span class="fc" id="L401">                    curAppNode.getApplicationParent().getDeleteNodes();</span>
            // Add childNode with delete operation in deleteList.
<span class="fc" id="L403">            deleteNodeList.add(childNode);</span>
<span class="fc" id="L404">            rootAppNode.setDeleteNodes(deleteNodeList);</span>
        }
<span class="fc" id="L406">    }</span>

    /**
     * Adds a last child to YANG app data tree.this method is to be used
     * internally by
     * other yang tools components.
     *
     * @param childNode                node to be added in tree
     * @param lastAugmentingModuleNode last augmenting module node
     * @param childOpType              operation type of node
     * @param isContextSwitch          to distinguish the call whether it
     *                                 module node call all its subNode call
     */
    private void addChildInAppTree(YdtNode childNode,
                                   YangSchemaNode lastAugmentingModuleNode,
                                   YdtContextOperationType childOpType,
                                   boolean isContextSwitch) {

        YdtAppNodeOperationType ydtAppNodeOperationType;

<span class="fc" id="L426">        DefaultYdtAppContext defaultYdtAppContext = new DefaultYdtAppContext();</span>
        // Add context switched child in ydt App tree.
<span class="fc" id="L428">        curAppNode.addChild(defaultYdtAppContext);</span>
        //Updating the curNode.
<span class="fc" id="L430">        curAppNode = defaultYdtAppContext;</span>

        // Get the app tree operation type from ydt operation type.
<span class="fc" id="L433">        ydtAppNodeOperationType =</span>
<span class="fc" id="L434">                curAppNode.getAppOpTypeFromYdtOpType(childOpType);</span>

<span class="pc bpc" id="L436" title="1 of 2 branches missed.">        if (isContextSwitch) {</span>
<span class="nc" id="L437">            curAppNode.setAugmentingModuleSchemaNode(lastAugmentingModuleNode);</span>

        } else {

            // If it is application rootNode then set the ydt application
            // root node.
<span class="fc" id="L443">            curAppNode.setModuleNode(childNode);</span>

            // Setting application root node to maintain the delete node list.
<span class="fc" id="L446">            curAppNode.setApplicationParent(curAppNode);</span>

            // Set the app tree operation type.
<span class="fc" id="L449">            curAppNode.setOperationType(ydtAppNodeOperationType);</span>
        }

        // Updating context switch flag for YdtNode
<span class="fc" id="L453">        childNode.setContextSwitch();</span>
<span class="fc" id="L454">    }</span>


    /**
     * Validate the various combination of operation type.
     * If the &quot;operation&quot; attribute is not specified,
     * then the operation applied to the parent data node of the configuration
     * is used.If no parent data node is available, then the
     * 'default-operation'value is used.
     *
     * @param parentOpType Reference for parent node operation type
     * @param childOpType  type of YANG data tree node operation
     */
    private void getOperationTypeValidate(YdtContextOperationType parentOpType,
                                          YdtContextOperationType childOpType) {

<span class="pc bpc" id="L470" title="1 of 3 branches missed.">        switch (parentOpType) {</span>
            case CREATE:
                // inside the create operation delete operation should not come.
<span class="nc bnc" id="L473" title="All 2 branches missed.">                if (childOpType == YdtContextOperationType.DELETE) {</span>
                    // Free resources
<span class="nc" id="L475">                    curNode.freeRestResources();</span>
<span class="nc" id="L476">                    throw new YdtExceptions(</span>
                            &quot;Create request is not allowed under delete &quot; +
                                    &quot;operation.&quot;);
                }
            case DELETE:
                // inside the delete operation create operation should not come.
<span class="pc bpc" id="L482" title="1 of 2 branches missed.">                if (childOpType == YdtContextOperationType.CREATE) {</span>
                    // Free resources
<span class="nc" id="L484">                    curNode.freeRestResources();</span>
<span class="nc" id="L485">                    throw new YdtExceptions(</span>
                            &quot;Delete request is not allowed under create &quot; +
                                    &quot;operation.&quot;);
                }

            default:

                //TODO check all possible scenario.
        }
<span class="fc" id="L494">    }</span>


    @Override
    public void addLeaf(String name, String namespace, String value) {
<span class="fc" id="L499">        addLeaf(name, namespace, value, null, RequestedCardinality.UNKNOWN);</span>
<span class="fc" id="L500">    }</span>

    @Override
    public void addLeaf(String name, String namespace, Set&lt;String&gt; valueSet) {
<span class="fc" id="L504">        addLeaf(name, namespace, null, valueSet,</span>
                RequestedCardinality.MULTI_INSTANCE_LEAF);
<span class="fc" id="L506">    }</span>


    /**
     * Adds a last leaf with list of values to YANG data tree. This method is
     * used by all protocols which knows the nature (single/multiple) or not.
     * Value of leaf can be null which indicates selection node in get
     * operation.
     *
     * @param name                 name of child to be added
     * @param namespace            namespace of child to be added, if it's
     *                             null, parent's
     *                             namespace will be applied to child
     * @param value                value of the child
     * @param valueSet             list of value of the child
     * @param requestedCardinality type of YANG data tree node operation.
     */

    private void addLeaf(String name, String namespace, String value,
                         Set&lt;String&gt; valueSet,
                         RequestedCardinality requestedCardinality) {

<span class="fc" id="L528">        YdtNode childNode =</span>
<span class="fc" id="L529">                addChild(name, namespace, requestedCardinality, null, true);</span>

        // After successful addition of child node updating the values in same.
<span class="fc bfc" id="L532" title="All 2 branches covered.">        if (value != null) {</span>
<span class="fc" id="L533">            childNode.addValue(value);</span>
        } else {
<span class="fc" id="L535">            childNode.addValueSet(valueSet);</span>
        }

        //Updating the curNode.
<span class="fc" id="L539">        curNode = childNode;</span>

<span class="fc" id="L541">    }</span>

    @Override
    public void traverseToParent() {
        // If node is of multiInstanceNode type then check key uniqueness.
<span class="fc bfc" id="L546" title="All 2 branches covered.">        if (curNode.getYdtType() == YdtType.MULTI_INSTANCE_NODE) {</span>
<span class="fc" id="L547">            curNode.createKeyNodeList();</span>
        }

        /**
         * Check application switch for curNode
         * if set, then traverseToParent in YDT application tree.
         */
<span class="pc bpc" id="L554" title="1 of 4 branches missed.">        if ((curNode.getParent() == rootNode) || (curNode.getContextSwitch())) {</span>
<span class="fc" id="L555">            traverseToParentYdtAppTree();</span>
        }

        /**
         * Validate all multi Instance inside current context.
         * this is not valid for leaf and leaf-list node.
         */
<span class="fc bfc" id="L562" title="All 4 branches covered.">        if ((curNode instanceof YdtMultiInstanceNode)</span>
                || (curNode instanceof YdtSingleInstanceNode)) {
<span class="fc" id="L564">            curNode.validateMultiInstanceNode();</span>
        }

<span class="fc" id="L567">        curNode = curNode.getParent();</span>
<span class="fc" id="L568">    }</span>

    /**
     * Traverses up in YANG application tree to the parent node,
     * this will be used when Ydt current context switch flag is set.
     */
    private void traverseToParentYdtAppTree() {
<span class="fc" id="L575">        curAppNode = curAppNode.getParent();</span>
<span class="fc" id="L576">    }</span>

    @Override
    public YdtContext getCurNode() {
<span class="fc" id="L580">        return curNode;</span>
    }

    @Override
    public void setDefaultEditOperationType(
            YdtContextOperationType ydtContextOperationType) {
<span class="nc" id="L586">        ydtContextDefaultOpType = ydtContextOperationType;</span>
<span class="nc" id="L587">    }</span>


    @Override
    public YdtExtendedContext getRootNode() {
<span class="fc" id="L592">        return rootNode;</span>
    }

    @Override
    public YmsOperationType getYmsOperationType() {
<span class="fc" id="L597">        return ymsOperationType;</span>
    }

    // TODO: need to address the name and name space handling
    @Override
    public void addMultiInstanceChild(String schemaName, String schemaNamespace,
                                      List&lt;String&gt; keysValueList) {
<span class="pc bpc" id="L604" title="1 of 2 branches missed.">        if (curNode.getYdtType() == YdtType.MULTI_INSTANCE_NODE) {</span>
<span class="fc" id="L605">            YangList yangListHolder = (YangList) curNode.getYangSchemaNode();</span>
<span class="fc" id="L606">            List&lt;String&gt; schemaKeyList = yangListHolder.getKeyList();</span>

<span class="fc bfc" id="L608" title="All 2 branches covered.">            if (schemaKeyList.size() &lt; keysValueList.size()) {</span>
                // Free resources
<span class="fc" id="L610">                curNode.freeRestResources();</span>
<span class="fc" id="L611">                throw new YdtExceptions(&quot;Too many key parameter in &quot; +</span>
<span class="fc" id="L612">                                                curNode.getYdtNodeIdentifier()</span>
<span class="fc" id="L613">                                                        .getName() +</span>
                                                &quot;. Expected fixed count &quot; +
<span class="fc" id="L615">                                                schemaKeyList.size() + &quot;.&quot;);</span>
<span class="fc bfc" id="L616" title="All 2 branches covered.">            } else if (schemaKeyList.size() &gt; keysValueList.size()) {</span>
                // Free resources
<span class="fc" id="L618">                curNode.freeRestResources();</span>
<span class="fc" id="L619">                throw new YdtExceptions(&quot;Too few key parameter in &quot; +</span>
<span class="fc" id="L620">                                                curNode.getYdtNodeIdentifier()</span>
<span class="fc" id="L621">                                                        .getName() +</span>
                                                &quot;. Expected fixed count &quot; +
<span class="fc" id="L623">                                                schemaKeyList.size() + &quot;.&quot;);</span>
            }

            // Iterator for user given key value.
<span class="fc" id="L627">            Iterator&lt;String&gt; it1 = keysValueList.iterator();</span>
            // Iterator for schema key name list.
<span class="fc" id="L629">            Iterator&lt;String&gt; it2 = schemaKeyList.iterator();</span>

            // This loop runs till user given key values are not finished.
<span class="pc bpc" id="L632" title="1 of 4 branches missed.">            while (it1.hasNext() &amp;&amp; it2.hasNext()) {</span>
<span class="fc" id="L633">                String value = it1.next();</span>
<span class="fc" id="L634">                String name = it2.next();</span>
<span class="fc" id="L635">                String namespace =</span>
<span class="fc" id="L636">                        curNode.getYdtNodeIdentifier().getNameSpace();</span>
<span class="fc" id="L637">                YdtContextOperationType opType =</span>
<span class="fc" id="L638">                        curNode.getYdtContextOperationType();</span>

<span class="fc" id="L640">                YangSchemaNodeIdentifier yangSchemaNodeIdentifier =</span>
                        new YangSchemaNodeIdentifier();
<span class="fc" id="L642">                yangSchemaNodeIdentifier.setName(name);</span>
<span class="fc" id="L643">                yangSchemaNodeIdentifier.setNameSpace(namespace);</span>

                YangSchemaNode yangSchemaNode;
                try {
<span class="fc" id="L647">                    yangSchemaNode = yangListHolder</span>
<span class="fc" id="L648">                            .getChildSchema(yangSchemaNodeIdentifier)</span>
<span class="fc" id="L649">                            .getSchemaNode();</span>
<span class="nc" id="L650">                } catch (DataModelException e) {</span>
                    // Free resources
<span class="nc" id="L652">                    curNode.freeRestResources();</span>
<span class="nc" id="L653">                    throw new YdtExceptions(e.getMessage());</span>
<span class="fc" id="L654">                }</span>
<span class="fc" id="L655">                YdtNode childNode =</span>
<span class="fc" id="L656">                        addExtendedChildNode(opType, yangSchemaNode);</span>
                // Update parent ydt node map.
<span class="fc" id="L658">                curNode.getParent()</span>
<span class="fc" id="L659">                        .updateYdtMap(yangSchemaNodeIdentifier, childNode);</span>
<span class="fc" id="L660">                curNode.addValue(value);</span>

<span class="fc bfc" id="L662" title="All 2 branches covered.">                if (it1.hasNext()) {</span>
<span class="fc" id="L663">                    traverseToParentExtended();</span>
                }
<span class="fc" id="L665">            }</span>
        }

<span class="fc" id="L668">    }</span>

    /**
     * Adds a last child to YANG data tree, this method is to be used by
     * YANG object builder sub-calls internally.
     *
     * @param opType type of requested operation over a node
     * @return returns added ydt node in YDT tree.
     */

    private YdtNode addExtendedChildNode(YdtContextOperationType opType,
                                         YangSchemaNode yangSchemaNode) {

        YdtNode childNode;
<span class="fc" id="L682">        YangSchemaNodeIdentifier nodeIdentifier =</span>
<span class="fc" id="L683">                yangSchemaNode.getYangSchemaNodeIdentifier();</span>

        // Get the ydtNode of respective type.
<span class="fc" id="L686">        childNode = YdtNodeFactory</span>
<span class="fc" id="L687">                .getYangSchemaNodeTypeSpecificContext(nodeIdentifier,</span>
                                                      yangSchemaNode
<span class="fc" id="L689">                                                              .getYangSchemaNodeType());</span>

        // Update node identifier.
<span class="fc" id="L692">        childNode.setNodeIdentifier(nodeIdentifier);</span>

        // Update yang schema node.
<span class="fc" id="L695">        childNode.setYangSchemaNode(yangSchemaNode);</span>

        // Update yang schema node.
<span class="fc" id="L698">        childNode.setYdtContextOperationType(opType);</span>

<span class="fc" id="L700">        curNode.addChild(childNode, true);</span>

        //Updating the curNode.
<span class="fc" id="L703">        curNode = childNode;</span>

<span class="fc" id="L705">        return childNode;</span>
    }

    @Override
    public YdtExtendedContext addChild(YdtContextOperationType opType,
                                       YangSchemaNode yangSchemaNode) {
        YdtExtendedContext childNode;
<span class="fc" id="L712">        childNode = addExtendedChildNode(opType, yangSchemaNode);</span>
<span class="fc" id="L713">        return childNode;</span>
    }

    @Override
    public YdtExtendedContext addLeaf(Set&lt;String&gt; valueSet,
                                      YangSchemaNode yangSchemaNode) {
        YdtNode childNode;
<span class="fc" id="L720">        childNode = addExtendedChildNode(null, yangSchemaNode);</span>

        // After successful addition of child node updating the values in same.
<span class="fc" id="L723">        childNode.addValueSetWithoutValidation(valueSet);</span>
<span class="fc" id="L724">        return childNode;</span>

    }

    @Override
    public YdtExtendedContext addLeaf(String value,
                                      YangSchemaNode yangSchemaNode) {
        YdtNode childNode;
<span class="fc" id="L732">        childNode = addExtendedChildNode(null, yangSchemaNode);</span>

        // After successful addition of child node updating the values in same.
<span class="fc" id="L735">        childNode.addValueWithoutValidation(value);</span>
<span class="fc" id="L736">        return childNode;</span>
    }

    @Override
    public void traverseToParentExtended() {
<span class="fc" id="L741">        curNode = curNode.getParent();</span>
<span class="fc" id="L742">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DefaultYangSchemaRegistry.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">onos-app-yms</a> &gt; <a href="index.source.html" class="el_package">org.onosproject.yms.app.ysr</a> &gt; <span class="el_source">DefaultYangSchemaRegistry.java</span></div><h1>DefaultYangSchemaRegistry.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2016-present Open Networking Laboratory
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.onosproject.yms.app.ysr;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.regex.Pattern;

import org.onosproject.yangutils.datamodel.RpcNotificationContainer;
import org.onosproject.yangutils.datamodel.YangNode;
import org.onosproject.yangutils.datamodel.YangRevision;
import org.onosproject.yangutils.datamodel.YangSchemaNode;
import org.onosproject.yangutils.datamodel.exceptions.DataModelException;
import org.osgi.framework.BundleContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static org.apache.commons.io.FileUtils.deleteDirectory;
import static org.onosproject.yangutils.utils.UtilConstants.DEFAULT;
import static org.onosproject.yangutils.utils.UtilConstants.EVENT_STRING;
import static org.onosproject.yangutils.utils.UtilConstants.OP_PARAM;
import static org.onosproject.yangutils.utils.UtilConstants.PERIOD;
import static org.onosproject.yangutils.utils.io.impl.YangIoUtils.getCapitalCase;
import static org.osgi.framework.FrameworkUtil.getBundle;


/**
 * Represent YANG schema registry. Yang schema registry provides interface to
 * an application to register its YANG schema
 * with YMS. It provides YANG schema nodes to YDT, YNB and YSB.
 */
public class DefaultYangSchemaRegistry
        implements YangSchemaRegistry {

    private static final String SYSTEM = &quot;/system/&quot;;
    private static final String MAVEN = &quot;mvn:&quot;;
    private static final String HYPHEN = &quot;-&quot;;
    private static final String DELIMITER = &quot;.&quot;;
    private static final String SERVICE = &quot;Service&quot;;
    private static final String SER = &quot;.ser&quot;;
    private static final String JAR = &quot;.jar&quot;;
    private static final String YANG = &quot;.yang&quot;;
    private static final String USER_DIRECTORY = &quot;user.dir&quot;;
<span class="fc" id="L74">    private static final String SLASH = File.separator;</span>

<span class="fc" id="L76">    private static final Logger log =</span>
<span class="fc" id="L77">            LoggerFactory.getLogger(DefaultYangSchemaRegistry.class);</span>

    /**
     * Map for storing app objects.
     */
    private ConcurrentMap&lt;String, YsrRegisteredAppContext&gt; appObjectStore;

    /**
     * Map for storing YANG schema nodes.
     */
    private ConcurrentMap&lt;String, YsrRegisteredAppContext&gt; yangSchemaStore;

    /**
     * Map for storing YANG schema nodes with respect to root's generated
     * interface file name.
     */
    private ConcurrentMap&lt;String, YsrRegisteredAppContext&gt;
            yangSchemaStoreForRootInterface;

    /**
     * Map for storing YANG schema nodes root's generated op param file name.
     */
    private ConcurrentMap&lt;String, YsrRegisteredAppContext&gt;
            yangSchemaStoreForRootOpParam;

    /**
     * Map for storing YANG schema nodes with respect to notifications.
     */
    private ConcurrentMap&lt;String, YsrRegisteredAppContext&gt;
            yangSchemaNotificationStore;

    /**
     * Map for storing registered classes.
     */
    private ConcurrentMap&lt;String, Class&lt;?&gt;&gt; registerClassStore;

    /**
     * Context of application which is registering with YMS.
     */
    private YsrRegisteredAppContext ysrRegisteredAppContext;

    /**
     * Context of application which is registering with YMS with multiple
     * revision.
     */
    private YsrRegisteredAppContext ysrRegisteredAppContextForSchemaMap;

    /**
     * Context of application which is registering with YMS with multiple
     * manager object.
     */
    private YsrRegisteredAppContext ysrAppContextForApplicationStore;

    /**
     * Class loader of service application.
     */
    private ClassLoader classLoader;

    /**
     * Creates an instance of YANG schema registry.
     */
<span class="fc" id="L138">    public DefaultYangSchemaRegistry() {</span>
<span class="fc" id="L139">        appObjectStore = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L140">        yangSchemaStore = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L141">        yangSchemaStoreForRootInterface = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L142">        yangSchemaStoreForRootOpParam = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L143">        yangSchemaNotificationStore = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L144">        registerClassStore = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L145">    }</span>

    /**
     * Returns app object store.
     *
     * @return app object store
     */
    private ConcurrentMap&lt;String, YsrRegisteredAppContext&gt; getAppObjectStore() {
<span class="fc" id="L153">        return appObjectStore;</span>
    }

    /**
     * Returns register class store.
     *
     * @return register class store.
     */
    private ConcurrentMap&lt;String, Class&lt;?&gt;&gt; getRegisterClassStore() {
<span class="fc" id="L162">        return registerClassStore;</span>
    }

    /**
     * Returns schema store.
     *
     * @return schema store
     */
    private ConcurrentMap&lt;String, YsrRegisteredAppContext&gt; getYangSchemaStore() {
<span class="fc" id="L171">        return yangSchemaStore;</span>
    }

    /**
     * Returns schema store.
     *
     * @return schema store
     */
    private ConcurrentMap&lt;String, YsrRegisteredAppContext&gt;
    getYangSchemaStoreForRootInterface() {
<span class="fc" id="L181">        return yangSchemaStoreForRootInterface;</span>
    }

    /**
     * Returns schema store.
     *
     * @return schema store
     */
    private ConcurrentMap&lt;String, YsrRegisteredAppContext&gt;
    getYangSchemaStoreForRootOpParam() {
<span class="fc" id="L191">        return yangSchemaStoreForRootOpParam;</span>
    }

    /**
     * Returns schema notification store.
     *
     * @return schema notification store
     */
    private ConcurrentMap&lt;String, YsrRegisteredAppContext&gt;
    getYangSchemaNotificationStore() {
<span class="fc" id="L201">        return yangSchemaNotificationStore;</span>
    }

    @Override
    public void registerApplication(Object appObject, Class&lt;?&gt; serviceClass) {

<span class="nc" id="L207">        BundleContext bundleContext =</span>
<span class="nc" id="L208">                getBundle(serviceClass).getBundleContext();</span>
<span class="nc" id="L209">        String jarPath = getJarPathFromBundleLocation(</span>
<span class="nc" id="L210">                bundleContext.getBundle().getLocation(),</span>
<span class="nc" id="L211">                bundleContext.getProperty(USER_DIRECTORY));</span>

        // set class loader for service class.
<span class="nc" id="L214">        setClassLoader(serviceClass.getClassLoader());</span>

        //Check if service should be registered?
<span class="nc" id="L217">        verifyApplicationRegistration(appObject, serviceClass);</span>

        //Add app class to registered serice store.
<span class="nc bnc" id="L220" title="All 2 branches missed.">        if (!getRegisterClassStore().containsKey(serviceClass.getName())) {</span>
<span class="nc" id="L221">            updateServiceClass(serviceClass);</span>
        }

        // process storing operations.
<span class="nc bnc" id="L225" title="All 2 branches missed.">        if (!verifyIfApplicationAlreadyRegistered(serviceClass)) {</span>
<span class="nc" id="L226">            List&lt;YangSchemaNode&gt; curNodes =</span>
<span class="nc" id="L227">                    processJarParsingOperations(jarPath);</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">            for (YangSchemaNode schemaNode : curNodes) {</span>
<span class="nc" id="L229">                processApplicationContext(schemaNode);</span>
<span class="nc" id="L230">            }</span>
<span class="nc" id="L231">            ysrAppContext().jarPath(jarPath);</span>
<span class="nc" id="L232">            ysrAppContextForSchemaStore().jarPath(jarPath);</span>
<span class="nc" id="L233">            ysrAppContextForApplicationStore().jarPath(jarPath);</span>
            //Store the YANG file handles.
<span class="nc" id="L235">            updateYangFileSet(jarPath);</span>
        }

        //Verifies if object is updated for app store.
<span class="nc" id="L239">        updateApplicationObject(appObject, serviceClass);</span>
<span class="nc" id="L240">    }</span>

    /**
     * Verifies if service class should be registered or not.
     *
     * @param appObject application object
     * @param appClass  application class
     */
    private void verifyApplicationRegistration(Object appObject,
                                               Class&lt;?&gt; appClass) {
<span class="nc" id="L250">        Class&lt;?&gt; managerClass = appObject.getClass();</span>
<span class="nc" id="L251">        Class&lt;?&gt;[] services = managerClass.getInterfaces();</span>
<span class="nc" id="L252">        List&lt;Class&lt;?&gt;&gt; classes = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L253">        Collections.addAll(classes, services);</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">        if (!classes.contains(appClass)) {</span>
<span class="nc" id="L255">            throw new RuntimeException(</span>
<span class="nc" id="L256">                    &quot;YSR: service class &quot; + appClass.getName()</span>
                            + &quot;is not being implemented by &quot;
<span class="nc" id="L258">                            + managerClass.getName());</span>
        }
<span class="nc" id="L260">    }</span>

    /**
     * Verifies if application is already registered with YMS.
     *
     * @param appClass application class
     * @return true if application already registered
     */
    private boolean verifyIfApplicationAlreadyRegistered(Class&lt;?&gt; appClass) {
<span class="nc" id="L269">        String appName = appClass.getSimpleName();</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">        if (!getAppObjectStore().containsKey(appClass.getName())) {</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">            if (appName.contains(OP_PARAM)) {</span>
<span class="nc" id="L272">                return getYangSchemaStoreForRootOpParam()</span>
<span class="nc" id="L273">                        .containsKey(appClass.getName());</span>
            } else {
<span class="nc" id="L275">                return getYangSchemaStoreForRootInterface()</span>
<span class="nc" id="L276">                        .containsKey(appClass.getName());</span>
            }
        }
<span class="nc" id="L279">        return true;</span>
    }

    /**
     * Verifies if service is being implemented by some new object.
     *
     * @param appObject application's object
     * @param appClass  application's class
     */
    private void updateApplicationObject(Object appObject, Class&lt;?&gt; appClass) {
<span class="nc bnc" id="L289" title="All 2 branches missed.">        if (getAppObjectStore().containsKey(appClass.getName())) {</span>
<span class="nc" id="L290">            YsrRegisteredAppContext appContext =</span>
<span class="nc" id="L291">                    getAppObjectStore().get(appClass.getName());</span>
<span class="nc" id="L292">            YangSchemaNode schemaNode = appContext.curNode();</span>
<span class="nc" id="L293">            String name = schemaNode.getJavaPackage() + PERIOD +</span>
<span class="nc" id="L294">                    getCapitalCase(schemaNode.getJavaClassNameOrBuiltInType());</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">            if (appContext.appObject() == null) {</span>
                //update in application store.
<span class="nc" id="L297">                appContext.appObject(appObject);</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">                if (getYangSchemaStoreForRootInterface().containsKey(name)) {</span>
<span class="nc" id="L299">                    getYangSchemaStoreForRootInterface().get(name)</span>
<span class="nc" id="L300">                            .appObject(appObject);</span>
                }
<span class="nc" id="L302">                if (getYangSchemaStoreForRootOpParam()</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">                        .containsKey(name + OP_PARAM)) {</span>
<span class="nc" id="L304">                    getYangSchemaStoreForRootOpParam().get(name + OP_PARAM)</span>
<span class="nc" id="L305">                            .appObject(appObject);</span>
                }
            }
        }
<span class="nc" id="L309">    }</span>

    @Override
    public void unRegisterApplication(Object managerObject,
                                      Class&lt;?&gt; serviceClass) {
<span class="fc" id="L314">        YangSchemaNode curNode = null;</span>
<span class="fc" id="L315">        String appName = serviceClass.getName();</span>

        //Remove registered class from store.
<span class="pc bpc" id="L318" title="1 of 2 branches missed.">        if (getRegisterClassStore().containsKey(serviceClass.getName())) {</span>
<span class="nc" id="L319">            getRegisterClassStore().remove(serviceClass.getName());</span>
        }

        //check if service is in app store.
<span class="fc bfc" id="L323" title="All 2 branches covered.">        if (getAppObjectStore().containsKey(serviceClass.getName())) {</span>
<span class="fc" id="L324">            curNode = retrieveNodeForUnregister(appName, getAppObjectStore());</span>
<span class="fc" id="L325">        } else if (getYangSchemaStoreForRootInterface()</span>
<span class="pc bpc" id="L326" title="1 of 2 branches missed.">                .containsKey(serviceClass.getName())) {</span>
            //check if service is in interface store.
<span class="nc" id="L328">            curNode = retrieveNodeForUnregister(appName,</span>
<span class="nc" id="L329">                                                getYangSchemaStoreForRootInterface());</span>
<span class="fc" id="L330">        } else if (getYangSchemaStoreForRootOpParam()</span>
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">                .containsKey(serviceClass.getName())) {</span>
            //check if service is in op param store.
<span class="nc" id="L333">            curNode = retrieveNodeForUnregister(appName,</span>
<span class="nc" id="L334">                                                getYangSchemaStoreForRootOpParam());</span>
        }
<span class="fc bfc" id="L336" title="All 2 branches covered.">        if (curNode != null) {</span>
<span class="fc" id="L337">            String javaName = curNode.getJavaPackage() + PERIOD +</span>
<span class="fc" id="L338">                    getCapitalCase(curNode.getJavaClassNameOrBuiltInType());</span>
<span class="fc" id="L339">            removeFromYangSchemaStore(curNode);</span>
<span class="fc" id="L340">            removeFromYangNotificationStore(curNode, javaName);</span>
<span class="fc" id="L341">            removeFromAppSchemaStore(appName);</span>
<span class="fc" id="L342">            removeFromYangSchemaNodeForRootInterface(javaName);</span>
<span class="fc" id="L343">            removeFromYangSchemaNodeForRootOpParam(javaName);</span>
<span class="fc" id="L344">            log.info(&quot;YSR: service &quot; + serviceClass.getSimpleName() +</span>
                             &quot; is unregistered.&quot;);
<span class="fc" id="L346">        } else {</span>
<span class="fc" id="L347">            log.error(&quot;YSR: service &quot; + serviceClass.getSimpleName() + &quot; was &quot; +</span>
                              &quot;not registered.&quot;);
        }
<span class="fc" id="L350">    }</span>

    @Override
    public Object getRegisteredApplication(YangSchemaNode schemaNode) {
<span class="fc bfc" id="L354" title="All 2 branches covered.">        if (schemaNode != null) {</span>
<span class="fc" id="L355">            String name = schemaNode.getJavaPackage() + PERIOD +</span>
<span class="fc" id="L356">                    getCapitalCase(schemaNode.getJavaClassNameOrBuiltInType());</span>
<span class="pc bpc" id="L357" title="1 of 2 branches missed.">            if (getYangSchemaStoreForRootInterface().containsKey(name)) {</span>
<span class="fc" id="L358">                return getYangSchemaStoreForRootInterface().get(name)</span>
<span class="fc" id="L359">                        .appObject();</span>
            }
<span class="nc" id="L361">            log.error(&quot;YSR: &quot; + name + &quot; not found.&quot;);</span>
        }
<span class="fc" id="L363">        return null;</span>
    }

    @Override
    public YangSchemaNode getYangSchemaNodeUsingSchemaName(String schemaName) {
<span class="fc bfc" id="L368" title="All 2 branches covered.">        if (getYangSchemaStore().containsKey(schemaName)) {</span>
<span class="fc" id="L369">            return getSchemaNodeUsingSchemaNameWithRev(schemaName);</span>
        }
<span class="fc" id="L371">        log.error(&quot;YSR: &quot; + schemaName + &quot; not found.&quot;);</span>
<span class="fc" id="L372">        return null;</span>
    }

    @Override
    public YangSchemaNode getYangSchemaNodeUsingAppName(String appName) {
<span class="fc bfc" id="L377" title="All 2 branches covered.">        if (getAppObjectStore().containsKey(appName)) {</span>
<span class="fc" id="L378">            return getAppObjectStore().get(appName).curNode();</span>
        }
<span class="fc" id="L380">        log.error(&quot;YSR: &quot; + appName + &quot; not found.&quot;);</span>
<span class="fc" id="L381">        return null;</span>
    }

    @Override
    public YangSchemaNode
    getYangSchemaNodeUsingGeneratedRootNodeInterfaceFileName(
            String rootInterfaceFileName) {
<span class="fc" id="L388">        if (getYangSchemaStoreForRootInterface()</span>
<span class="fc bfc" id="L389" title="All 2 branches covered.">                .containsKey(rootInterfaceFileName)) {</span>
<span class="fc" id="L390">            return getYangSchemaStoreForRootInterface()</span>
<span class="fc" id="L391">                    .get(rootInterfaceFileName).curNode();</span>
        }
<span class="fc" id="L393">        log.error(&quot;YSR: &quot; + rootInterfaceFileName + &quot; not found.&quot;);</span>
<span class="fc" id="L394">        return null;</span>
    }

    @Override
    public YangSchemaNode getYangSchemaNodeUsingGeneratedRootNodeOpPramFileName(
            String rootOpParamFileName) {
<span class="fc" id="L400">        if (getYangSchemaStoreForRootOpParam()</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">                .containsKey(rootOpParamFileName)) {</span>
<span class="fc" id="L402">            return getYangSchemaStoreForRootOpParam().get(rootOpParamFileName)</span>
<span class="fc" id="L403">                    .curNode();</span>
        }
<span class="fc" id="L405">        log.error(&quot;YSR: &quot; + rootOpParamFileName + &quot; not found.&quot;);</span>
<span class="fc" id="L406">        return null;</span>
    }

    @Override
    public YangSchemaNode getRootYangSchemaNodeForNotification(
            String eventSubject) {
<span class="fc bfc" id="L412" title="All 2 branches covered.">        if (getYangSchemaNotificationStore().containsKey(eventSubject)) {</span>
<span class="fc" id="L413">            return getYangSchemaNotificationStore().get(eventSubject).curNode();</span>
        }
<span class="fc" id="L415">        log.error(&quot;YSR: &quot; + eventSubject + &quot; not found.&quot;);</span>
<span class="fc" id="L416">        return null;</span>
    }

    public Class&lt;?&gt; getRegisteredClass(YangSchemaNode schemaNode,
                                       String appName) {
<span class="fc" id="L421">        String interfaceName = schemaNode.getJavaPackage() + PERIOD +</span>
<span class="fc" id="L422">                getCapitalCase(schemaNode.getJavaClassNameOrBuiltInType());</span>
<span class="fc" id="L423">        String serviceName = interfaceName + SERVICE;</span>
        String defaultClass;
<span class="pc bpc" id="L425" title="1 of 2 branches missed.">        if (schemaNode instanceof RpcNotificationContainer) {</span>
<span class="fc" id="L426">            defaultClass = schemaNode.getJavaPackage()</span>
<span class="fc" id="L427">                    + getCapitalCase(schemaNode.getJavaClassNameOrBuiltInType()</span>
                                             + OP_PARAM);
        } else {
<span class="nc" id="L430">            defaultClass = schemaNode.getJavaPackage() + PERIOD</span>
<span class="nc" id="L431">                    + getCapitalCase(DEFAULT) +</span>
<span class="nc" id="L432">                    getCapitalCase(schemaNode.getJavaClassNameOrBuiltInType());</span>
        }
        //If application class is registered.
<span class="pc bpc" id="L435" title="1 of 2 branches missed.">        if (getRegisterClassStore().containsKey(appName)) {</span>
<span class="nc" id="L436">            return getRegisterClassStore().get(appName);</span>
<span class="pc bpc" id="L437" title="1 of 2 branches missed.">        } else if (getRegisterClassStore().containsKey(interfaceName)) {</span>
            //If interface class is registered.
<span class="fc" id="L439">            return getRegisterClassStore().get(interfaceName);</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">        } else if (getRegisterClassStore().containsKey(serviceName)) {</span>
            //If service class is registered.
<span class="nc" id="L442">            return getRegisterClassStore().get(serviceName);</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">        } else if (getRegisterClassStore().containsKey(defaultClass)) {</span>
            //If default class is registered.
<span class="nc" id="L445">            return getRegisterClassStore().get(defaultClass);</span>
        }
<span class="nc" id="L447">        return null;</span>
    }

    /**
     * Returns notification schema store.
     *
     * @return notification schema store
     */
    private ConcurrentMap&lt;String, YsrRegisteredAppContext&gt;
    getNotificationSchemaMap() {
<span class="nc" id="L457">        return getYangSchemaNotificationStore();</span>
    }

    /**
     * Updates service class store.
     *
     * @param serviceClass service class
     */
    void updateServiceClass(Class&lt;?&gt; serviceClass) {
<span class="fc" id="L466">        getRegisterClassStore().put(serviceClass.getName(), serviceClass);</span>
<span class="fc" id="L467">    }</span>

    /**
     * Updates application object store.
     *
     * @param appName application name
     */
    private void updateAppObjectStore(String appName) {
<span class="fc bfc" id="L475" title="All 2 branches covered.">        if (verifyClassExistence(appName)) {</span>
<span class="fc" id="L476">            getAppObjectStore()</span>
<span class="fc" id="L477">                    .put(appName, ysrAppContextForApplicationStore());</span>
        }
<span class="fc" id="L479">    }</span>

    /**
     * Updates YANG schema object store.
     *
     * @param schemaNode application's schema node
     */
    private void updateYangSchemaStore(YangSchemaNode schemaNode) {
<span class="fc" id="L487">        addSchemaNodeUsingSchemaNameWithRev(schemaNode);</span>
<span class="fc" id="L488">    }</span>

    /**
     * Updates YANG schema notification object store.
     *
     * @param notificationName application's notification name
     */
    private void updateYangNotificationStore(String notificationName) {
<span class="pc bpc" id="L496" title="1 of 2 branches missed.">        if (verifyClassExistence(notificationName)) {</span>
<span class="fc" id="L497">            getYangSchemaNotificationStore()</span>
<span class="fc" id="L498">                    .put(notificationName, ysrAppContext());</span>
        }
<span class="fc" id="L500">    }</span>

    /**
     * Updates YANG schema object store for root interface file name.
     *
     * @param rootInterfaceFileName name of generated interface file for root
     *                              node
     */
    private void updateYangSchemaForRootInterfaceFileNameStore(
            String rootInterfaceFileName) {
<span class="fc bfc" id="L510" title="All 2 branches covered.">        if (verifyClassExistence(rootInterfaceFileName)) {</span>
<span class="fc" id="L511">            getYangSchemaStoreForRootInterface()</span>
<span class="fc" id="L512">                    .put(rootInterfaceFileName, ysrAppContext());</span>
        }
<span class="fc" id="L514">    }</span>

    /**
     * Updates YANG schema object store  for root op param file name.
     *
     * @param rootOpParamFileName name of generated op param file for root node
     */
    private void updateYangSchemaForRootOpParamFileNameStore(
            String rootOpParamFileName) {
<span class="fc bfc" id="L523" title="All 2 branches covered.">        if (verifyClassExistence(rootOpParamFileName)) {</span>
<span class="fc" id="L524">            getYangSchemaStoreForRootOpParam()</span>
<span class="fc" id="L525">                    .put(rootOpParamFileName, ysrAppContext());</span>
        }
<span class="fc" id="L527">    }</span>

    /**
     * Updates the YANG file set.
     *
     * @param path YANG file path
     */
    private void updateYangFileSet(String path) {
<span class="nc" id="L535">        File yangFilePath = new File(path);</span>
<span class="nc" id="L536">        File[] fileArray = yangFilePath.listFiles();</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">        if (fileArray != null) {</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">            for (File curFile : fileArray) {</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">                if (curFile.getName().endsWith(YANG)) {</span>
<span class="nc" id="L540">                    ysrAppContext().addToYangFileSet(curFile);</span>
<span class="nc" id="L541">                    ysrAppContextForSchemaStore()</span>
<span class="nc" id="L542">                            .addToYangFileSet(curFile);</span>
<span class="nc" id="L543">                    ysrAppContextForApplicationStore()</span>
<span class="nc" id="L544">                            .addToYangFileSet(curFile);</span>
                }
            }
        }
<span class="nc" id="L548">    }</span>

    /**
     * Process jar file for fetching YANG nodes.
     *
     * @param path jar file path
     * @return YANG schema nodes
     */
    private List&lt;YangSchemaNode&gt; processJarParsingOperations(String path) {
        //Deserialize data model and get the YANG node set.
<span class="nc" id="L558">        return parseJarFile(path + JAR, path);</span>
    }

    /**
     * Process an application an updates the maps for YANG schema registry.
     *
     * @param appNode application YANG schema nodes
     */
    void processApplicationContext(YangSchemaNode appNode) {

<span class="fc" id="L568">        String appName = appNode.getJavaPackage() + PERIOD +</span>
<span class="fc" id="L569">                getCapitalCase(appNode.getJavaClassNameOrBuiltInType());</span>

        //Create a new instance of ysr app context for each node.
<span class="fc" id="L572">        ysrAppContext(new YsrRegisteredAppContext());</span>
<span class="fc" id="L573">        ysrAppContextForSchemaStore(new YsrRegisteredAppContext());</span>
<span class="fc" id="L574">        ysrAppContextForApplicationStore(new YsrRegisteredAppContext());</span>

        //add cur node to app context.
<span class="fc" id="L577">        ysrAppContext().curNode(appNode);</span>
<span class="fc" id="L578">        ysrAppContextForApplicationStore().curNode(appNode);</span>

        //Updates maps wih schema nodes
<span class="fc" id="L581">        updateAppObjectStore(appName + SERVICE);</span>

        // Updates schema store
<span class="fc" id="L584">        updateYangSchemaStore(appNode);</span>
        // update interface store
<span class="fc" id="L586">        updateYangSchemaForRootInterfaceFileNameStore(appName);</span>
        //update op param store
<span class="fc" id="L588">        updateYangSchemaForRootOpParamFileNameStore(appName + OP_PARAM);</span>
        //Checks if notification is present then update notification store map.
<span class="fc" id="L590">        String eventSubject = null;</span>
        try {
<span class="fc bfc" id="L592" title="All 2 branches covered.">            if (appNode.isNotificationPresent()) {</span>
<span class="fc" id="L593">                eventSubject = appName.toLowerCase() + PERIOD +</span>
<span class="fc" id="L594">                        getCapitalCase(</span>
<span class="fc" id="L595">                                appNode.getJavaClassNameOrBuiltInType()) +</span>
                        EVENT_STRING;
            }
<span class="nc" id="L598">        } catch (DataModelException e) {</span>
<span class="nc" id="L599">            e.printStackTrace();</span>
<span class="fc" id="L600">        }</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">        if (eventSubject != null) {</span>
<span class="fc" id="L602">            updateYangNotificationStore(eventSubject);</span>
        }
<span class="fc" id="L604">        log.info(&quot;YSR: successfully registered this application &quot; + appName +</span>
                         SERVICE);

<span class="fc" id="L607">    }</span>

    /**
     * Parses jar file and returns list of serialized file names.
     *
     * @param jarFile   jar file to be parsed
     * @param directory directory where to search
     * @return list of serialized files
     */
    private List&lt;YangSchemaNode&gt; parseJarFile(String jarFile,
                                              String directory) {

<span class="nc" id="L619">        List&lt;YangSchemaNode&gt; nodes = new ArrayList&lt;&gt;();</span>
        try {
<span class="nc" id="L621">            JarFile jar = new JarFile(jarFile);</span>
<span class="nc" id="L622">            Enumeration&lt;?&gt; enumEntries = jar.entries();</span>

<span class="nc bnc" id="L624" title="All 2 branches missed.">            while (enumEntries.hasMoreElements()) {</span>
<span class="nc" id="L625">                JarEntry file = (JarEntry) enumEntries.nextElement();</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">                if (file.getName().endsWith(SER)) {</span>
<span class="nc bnc" id="L627" title="All 2 branches missed.">                    if (file.getName().contains(SLASH)) {</span>
<span class="nc" id="L628">                        String[] strArray = file.getName().split(SLASH);</span>
<span class="nc" id="L629">                        String tempPath = &quot;&quot;;</span>
<span class="nc bnc" id="L630" title="All 2 branches missed.">                        for (int i = 0; i &lt; strArray.length - 1; i++) {</span>
<span class="nc" id="L631">                            tempPath = SLASH + tempPath + SLASH + strArray[i];</span>
                        }
<span class="nc" id="L633">                        File dir = new File(directory + tempPath);</span>
<span class="nc" id="L634">                        dir.mkdirs();</span>
                    }
<span class="nc" id="L636">                    File serializedFile =</span>
<span class="nc" id="L637">                            new File(directory + SLASH + file.getName());</span>
<span class="nc bnc" id="L638" title="All 2 branches missed.">                    if (file.isDirectory()) {</span>
<span class="nc" id="L639">                        serializedFile.mkdirs();</span>
<span class="nc" id="L640">                        continue;</span>
                    }
<span class="nc" id="L642">                    InputStream inputStream = jar.getInputStream(file);</span>

<span class="nc" id="L644">                    FileOutputStream fileOutputStream =</span>
                            new FileOutputStream(serializedFile);
<span class="nc bnc" id="L646" title="All 2 branches missed.">                    while (inputStream.available() &gt; 0) {</span>
<span class="nc" id="L647">                        fileOutputStream.write(inputStream.read());</span>
                    }
<span class="nc" id="L649">                    fileOutputStream.close();</span>
<span class="nc" id="L650">                    inputStream.close();</span>
<span class="nc" id="L651">                    nodes.addAll(</span>
<span class="nc" id="L652">                            deSerializeDataModel(serializedFile.toString()));</span>
                }
<span class="nc" id="L654">            }</span>
<span class="nc" id="L655">            jar.close();</span>
<span class="nc" id="L656">        } catch (IOException e) {</span>
<span class="nc" id="L657">            log.error(</span>
                    &quot;YSR: failed to fetch yang nodes from jar file for &quot; +
                            &quot;application &quot; +
<span class="nc" id="L660">                            ysrAppContext().appObject());</span>
<span class="nc" id="L661">            e.printStackTrace();</span>
<span class="nc" id="L662">        }</span>
<span class="nc" id="L663">        return nodes;</span>
    }


    /**
     * Returns jar path from bundle mvnLocationPath.
     *
     * @param mvnLocationPath mvnLocationPath of bundle
     * @return path of jar
     */
    private String getJarPathFromBundleLocation(String mvnLocationPath,
                                                String currentDirectory) {
<span class="nc" id="L675">        String path = currentDirectory + SYSTEM;</span>
<span class="nc" id="L676">        String[] strArray = mvnLocationPath.split(MAVEN);</span>
<span class="nc" id="L677">        String[] split = strArray[1].split(File.separator);</span>
<span class="nc" id="L678">        String[] groupId = split[0].split(Pattern.quote(DELIMITER));</span>

<span class="nc" id="L680">        path = path + groupId[0] + SLASH + groupId[1] + SLASH + split[1] +</span>
                SLASH + split[2] + SLASH + split[1] + HYPHEN + split[2];
<span class="nc" id="L682">        return path;</span>
    }

    /**
     * Returns de-serializes YANG data-model nodes.
     *
     * @param serializedFileInfo serialized File Info
     * @return de-serializes YANG data-model nodes
     */
    Set&lt;YangSchemaNode&gt; deSerializeDataModel(String serializedFileInfo) {

<span class="fc" id="L693">        Set&lt;YangSchemaNode&gt; nodes = new HashSet&lt;&gt;();</span>
        try {
<span class="fc" id="L695">            FileInputStream fileInputStream =</span>
                    new FileInputStream(serializedFileInfo);
<span class="fc" id="L697">            ObjectInputStream objectInputStream =</span>
                    new ObjectInputStream(fileInputStream);
<span class="fc" id="L699">            nodes = (Set&lt;YangSchemaNode&gt;) objectInputStream.readObject();</span>
<span class="fc" id="L700">            objectInputStream.close();</span>
<span class="fc" id="L701">            fileInputStream.close();</span>
<span class="nc" id="L702">        } catch (IOException | ClassNotFoundException e) {</span>
<span class="nc" id="L703">            e.printStackTrace();</span>
<span class="nc" id="L704">            log.error(serializedFileInfo + &quot; not found.&quot;);</span>
<span class="fc" id="L705">        }</span>

<span class="fc" id="L707">        return nodes;</span>
    }

    /**
     * Returns ysr app context.
     *
     * @return ysr app context
     */
    YsrRegisteredAppContext ysrAppContext() {
<span class="fc" id="L716">        return ysrRegisteredAppContext;</span>
    }

    /**
     * Sets ysr app context.
     *
     * @param ysrRegisteredAppContext ysr app context
     */
    private void ysrAppContext(
            YsrRegisteredAppContext ysrRegisteredAppContext) {
<span class="fc" id="L726">        this.ysrRegisteredAppContext = ysrRegisteredAppContext;</span>
<span class="fc" id="L727">    }</span>

    /**
     * Returns schema node based on the revision.
     *
     * @param name name of the schema node
     * @return schema node based on the revision.
     */
    private YangSchemaNode getSchemaNodeUsingSchemaNameWithRev(String name) {
        YsrRegisteredAppContext appContext;
        YangSchemaNode schemaNode;
<span class="pc bpc" id="L738" title="1 of 2 branches missed.">        if (name.contains(&quot;@&quot;)) {</span>
<span class="nc" id="L739">            String[] revArray = name.split(&quot;@&quot;);</span>
<span class="nc" id="L740">            appContext = getYangSchemaStore().get(revArray[0]);</span>
<span class="nc" id="L741">            schemaNode = appContext.getSchemaNodeForRevisionStore(name);</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">            if (schemaNode != null) {</span>
<span class="nc" id="L743">                return schemaNode;</span>
            }
<span class="nc" id="L745">            return appContext.curNode();</span>
        }
<span class="fc" id="L747">        appContext = getYangSchemaStore().get(name);</span>
<span class="pc bpc" id="L748" title="1 of 2 branches missed.">        if (appContext != null) {</span>
<span class="fc" id="L749">            Iterator&lt;YangSchemaNode&gt; iterator =</span>
<span class="fc" id="L750">                    appContext.getYangSchemaNodeForRevisionStore().values()</span>
<span class="fc" id="L751">                            .iterator();</span>
<span class="pc bpc" id="L752" title="1 of 2 branches missed.">            if (iterator.hasNext()) {</span>
<span class="fc" id="L753">                return appContext.getYangSchemaNodeForRevisionStore().values()</span>
<span class="fc" id="L754">                        .iterator().next();</span>
            } else {
<span class="nc" id="L756">                return null;</span>
            }
        }
<span class="nc" id="L759">        return null;</span>
    }

    /**
     * Adds schema node when different revision of node has received.
     *
     * @param schemaNode schema node
     */
    private void addSchemaNodeUsingSchemaNameWithRev(
            YangSchemaNode schemaNode) {

<span class="fc" id="L770">        String date = getDateInStringFormat(schemaNode);</span>
<span class="fc" id="L771">        String name = schemaNode.getName();</span>
<span class="fc bfc" id="L772" title="All 2 branches covered.">        if (!date.equals(&quot;&quot;)) {</span>
<span class="fc" id="L773">            name = name + &quot;@&quot; + date;</span>
        }
        //check if already present.
<span class="fc bfc" id="L776" title="All 2 branches covered.">        if (!getYangSchemaStore().containsKey(schemaNode.getName())) {</span>
<span class="fc" id="L777">            ysrAppContextForSchemaStore().curNode(schemaNode);</span>
            //if revision is not present no need to add in revision store.
<span class="fc" id="L779">            ysrAppContextForSchemaStore()</span>
<span class="fc" id="L780">                    .addSchemaNodeWithRevisionStore(name, schemaNode);</span>
<span class="fc" id="L781">            getYangSchemaStore().put(schemaNode.getName(),</span>
<span class="fc" id="L782">                                     ysrAppContextForSchemaStore());</span>
        } else {
<span class="fc" id="L784">            YsrRegisteredAppContext appContext =</span>
<span class="fc" id="L785">                    getYangSchemaStore().get(schemaNode.getName());</span>
<span class="fc" id="L786">            appContext.addSchemaNodeWithRevisionStore(name, schemaNode);</span>
<span class="fc" id="L787">            appContext.curNode(schemaNode);</span>
        }
<span class="fc" id="L789">    }</span>

    /**
     * Returns date in string format.
     *
     * @param schemaNode schema node
     * @return date in string format.
     */
    private String getDateInStringFormat(YangSchemaNode schemaNode) {
<span class="pc bpc" id="L798" title="1 of 2 branches missed.">        if (schemaNode != null) {</span>
<span class="fc bfc" id="L799" title="All 2 branches covered.">            if (((YangNode) schemaNode).getRevision() != null) {</span>
<span class="fc" id="L800">                return new SimpleDateFormat(&quot;yyyy-mm-dd&quot;)</span>
<span class="fc" id="L801">                        .format(((YangNode) schemaNode).getRevision()</span>
<span class="fc" id="L802">                                        .getRevDate());</span>
            }
        }
<span class="fc" id="L805">        return &quot;&quot;;</span>
    }

    /**
     * Removes schema node from schema map.
     *
     * @param removableNode schema node which needs to be removed
     */
    private void removeSchemaNode(YangSchemaNode removableNode) {

<span class="fc" id="L815">        YangRevision removeNodeRev = ((YangNode) removableNode).getRevision();</span>
<span class="fc" id="L816">        String name = removableNode.getName();</span>
<span class="fc bfc" id="L817" title="All 2 branches covered.">        if (removeNodeRev != null) {</span>
<span class="fc" id="L818">            name = removableNode.getName() + &quot;@&quot; +</span>
<span class="fc" id="L819">                    getDateInStringFormat(removableNode);</span>
        }
<span class="fc" id="L821">        YsrRegisteredAppContext appContext = getYangSchemaStore()</span>
<span class="fc" id="L822">                .get(removableNode.getName());</span>
<span class="pc bpc" id="L823" title="1 of 2 branches missed.">        if (!appContext.getYangSchemaNodeForRevisionStore().isEmpty()</span>
<span class="fc bfc" id="L824" title="All 2 branches covered.">                &amp;&amp; appContext.getYangSchemaNodeForRevisionStore().size() != 1) {</span>
<span class="fc" id="L825">            appContext.removeSchemaNodeForRevisionStore(name);</span>
        } else {
<span class="fc" id="L827">            getYangSchemaStore().remove(removableNode.getName());</span>
        }
<span class="fc" id="L829">    }</span>

    /**
     * Verifies if the manager object is already registered with notification
     * handler.
     *
     * @param serviceClass service class
     * @return true if the manager object is already registered with
     * notification handler.
     */
    public boolean verifyNotificationObject(Class&lt;?&gt; serviceClass) {
<span class="nc" id="L840">        YangSchemaNode schemaNode = null;</span>
<span class="nc bnc" id="L841" title="All 2 branches missed.">        if (getAppObjectStore().containsKey(serviceClass.getName())) {</span>
<span class="nc" id="L842">            schemaNode = getYangSchemaNodeUsingAppName(serviceClass.getName());</span>
<span class="nc" id="L843">        } else if (getYangSchemaStoreForRootInterface()</span>
<span class="nc bnc" id="L844" title="All 2 branches missed.">                .containsKey(serviceClass.getName())) {</span>
<span class="nc" id="L845">            schemaNode =</span>
<span class="nc" id="L846">                    getYangSchemaNodeUsingGeneratedRootNodeInterfaceFileName(</span>
<span class="nc" id="L847">                            serviceClass.getName());</span>
<span class="nc" id="L848">        } else if (getYangSchemaStoreForRootOpParam()</span>
<span class="nc bnc" id="L849" title="All 2 branches missed.">                .containsKey(serviceClass.getName())) {</span>
<span class="nc" id="L850">            schemaNode = getYangSchemaNodeUsingGeneratedRootNodeOpPramFileName(</span>
<span class="nc" id="L851">                    serviceClass.getName());</span>
        }

<span class="nc bnc" id="L854" title="All 2 branches missed.">        if (schemaNode != null) {</span>
<span class="nc" id="L855">            String name = (schemaNode.getJavaPackage() + PERIOD +</span>
<span class="nc" id="L856">                    schemaNode.getJavaClassNameOrBuiltInType() + PERIOD)</span>
<span class="nc" id="L857">                    .toLowerCase()</span>
                    +
<span class="nc" id="L859">                    getCapitalCase(schemaNode.getJavaClassNameOrBuiltInType()) +</span>
                    EVENT_STRING;

<span class="nc bnc" id="L862" title="All 2 branches missed.">            if (getNotificationSchemaMap().containsKey(name)) {</span>
<span class="nc" id="L863">                if (!getNotificationSchemaMap().get(name)</span>
<span class="nc bnc" id="L864" title="All 2 branches missed.">                        .isNotificationRegistered()) {</span>
<span class="nc" id="L865">                    getNotificationSchemaMap().get(name)</span>
<span class="nc" id="L866">                            .setNotificationRegistered(true);</span>
<span class="nc" id="L867">                    return true;</span>
                }
            }
        }

<span class="nc" id="L872">        return false;</span>

    }

    /**
     * Returns YSR application context for schema map.
     *
     * @return YSR application context for schema map
     */
    YsrRegisteredAppContext ysrAppContextForSchemaStore() {
<span class="fc" id="L882">        return ysrRegisteredAppContextForSchemaMap;</span>
    }

    /**
     * Sets YSR application context for schema map.
     *
     * @param ysrRegisteredAppContextForSchemaMap YSR application context for
     *                                            schema map
     */
    void ysrAppContextForSchemaStore(
            YsrRegisteredAppContext ysrRegisteredAppContextForSchemaMap) {
<span class="fc" id="L893">        this.ysrRegisteredAppContextForSchemaMap =</span>
                ysrRegisteredAppContextForSchemaMap;
<span class="fc" id="L895">    }</span>

    /**
     * Returns YSR app context for application store.
     *
     * @return YSR app context for application store
     */
    YsrRegisteredAppContext ysrAppContextForApplicationStore() {
<span class="fc" id="L903">        return ysrAppContextForApplicationStore;</span>
    }

    /**
     * Sets YSR app context for application store.
     *
     * @param ysrAppContextForApplicationMap YSR app context for application
     *                                       store
     */
    private void ysrAppContextForApplicationStore(
            YsrRegisteredAppContext ysrAppContextForApplicationMap) {
<span class="fc" id="L914">        this.ysrAppContextForApplicationStore = ysrAppContextForApplicationMap;</span>
<span class="fc" id="L915">    }</span>

    /**
     * Retrieves schema node from the store and deletes jar file path.
     *
     * @param appName application name
     * @param store   YSR stores
     * @return schema node from the store
     */
    private YangSchemaNode retrieveNodeForUnregister(String appName,
                                                     ConcurrentMap&lt;String,
                                                             YsrRegisteredAppContext&gt; store) {
<span class="fc" id="L927">        YsrRegisteredAppContext curContext = store.get(appName);</span>
<span class="fc" id="L928">        YangSchemaNode curNode = curContext.curNode();</span>
        //Delete all the generated ysr information in application's package.
<span class="pc bpc" id="L930" title="1 of 2 branches missed.">        if (curContext.jarPath() != null) {</span>
<span class="nc" id="L931">            File jarPath = new File(curContext.jarPath());</span>
<span class="nc bnc" id="L932" title="All 2 branches missed.">            if (jarPath.exists()) {</span>
                try {
<span class="nc" id="L934">                    deleteDirectory(new File(curContext.jarPath()));</span>
<span class="nc" id="L935">                } catch (IOException e) {</span>
<span class="nc" id="L936">                    log.error(&quot;failed to delete ysr resources for &quot; + appName);</span>
<span class="nc" id="L937">                    e.printStackTrace();</span>
<span class="nc" id="L938">                }</span>
            }
        }
<span class="fc" id="L941">        return curNode;</span>
    }

    /**
     * Removes from YANG schema store.
     *
     * @param curNode schema node
     */
    private void removeFromYangSchemaStore(YangSchemaNode curNode) {
<span class="pc bpc" id="L950" title="1 of 2 branches missed.">        if (getYangSchemaStore().containsKey(curNode.getName())) {</span>
<span class="fc" id="L951">            removeSchemaNode(curNode);</span>
        }
<span class="fc" id="L953">    }</span>

    /**
     * Removes from YANG schema  notification store.
     *
     * @param curNode schema node
     */
    private void removeFromYangNotificationStore(YangSchemaNode curNode,
                                                 String appName) {
<span class="fc" id="L962">        appName = appName.toLowerCase() + PERIOD +</span>
<span class="fc" id="L963">                getCapitalCase(curNode.getJavaClassNameOrBuiltInType()) +</span>
                EVENT_STRING;
<span class="fc" id="L965">        if (getYangSchemaNotificationStore()</span>
<span class="fc bfc" id="L966" title="All 2 branches covered.">                .containsKey(appName)) {</span>
<span class="fc" id="L967">            getYangSchemaNotificationStore()</span>
<span class="fc" id="L968">                    .remove(appName);</span>
        }
<span class="fc" id="L970">    }</span>

    /**
     * Removes from app store.
     *
     * @param appName application name
     */
    private void removeFromAppSchemaStore(String appName) {
<span class="pc bpc" id="L978" title="1 of 2 branches missed.">        if (getAppObjectStore().containsKey(appName)) {</span>
<span class="fc" id="L979">            getAppObjectStore().remove(appName);</span>
        }
<span class="fc" id="L981">    }</span>

    /**
     * Removes from interface store.
     *
     * @param appName application name
     */
    private void removeFromYangSchemaNodeForRootInterface(String appName) {
<span class="fc" id="L989">        if (getYangSchemaStoreForRootInterface()</span>
<span class="pc bpc" id="L990" title="1 of 2 branches missed.">                .containsKey(appName)) {</span>
<span class="fc" id="L991">            getYangSchemaStoreForRootInterface().remove(appName);</span>
        }
<span class="fc" id="L993">    }</span>

    /**
     * Removes from op param store.
     *
     * @param appName application name
     */
    private void removeFromYangSchemaNodeForRootOpParam(String appName) {
<span class="fc" id="L1001">        if (getYangSchemaStoreForRootOpParam()</span>
<span class="pc bpc" id="L1002" title="1 of 2 branches missed.">                .containsKey(appName + OP_PARAM)) {</span>
<span class="fc" id="L1003">            getYangSchemaStoreForRootOpParam()</span>
<span class="fc" id="L1004">                    .remove(appName + OP_PARAM);</span>
        }
<span class="fc" id="L1006">    }</span>

    /**
     * Returns class loader of service class.
     *
     * @return class loader of service class
     */
    private ClassLoader getClassLoader() {
<span class="fc" id="L1014">        return classLoader;</span>
    }

    /**
     * Sets class loader of service class.
     *
     * @param classLoader class loader of service class
     */
    void setClassLoader(ClassLoader classLoader) {
<span class="fc" id="L1023">        this.classLoader = classLoader;</span>
<span class="fc" id="L1024">    }</span>

    /**
     * Verifies if class with given name exists.
     *
     * @param appName application name
     * @return true if class exists
     */
    boolean verifyClassExistence(String appName) {
        try {
<span class="fc" id="L1034">            getClassLoader().loadClass(appName);</span>
<span class="fc" id="L1035">            return true;</span>
<span class="fc" id="L1036">        } catch (ClassNotFoundException e) {</span>
<span class="fc" id="L1037">            return false;</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>
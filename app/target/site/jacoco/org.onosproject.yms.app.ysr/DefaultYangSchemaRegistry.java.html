<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DefaultYangSchemaRegistry.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">onos-app-yms</a> &gt; <a href="index.source.html" class="el_package">org.onosproject.yms.app.ysr</a> &gt; <span class="el_source">DefaultYangSchemaRegistry.java</span></div><h1>DefaultYangSchemaRegistry.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2016-present Open Networking Laboratory
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.onosproject.yms.app.ysr;

import org.onosproject.yangutils.datamodel.YangNode;
import org.onosproject.yangutils.datamodel.YangRevision;
import org.onosproject.yangutils.datamodel.YangSchemaNode;
import org.onosproject.yangutils.datamodel.exceptions.DataModelException;
import org.osgi.framework.BundleContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.regex.Pattern;

import static org.apache.commons.io.FileUtils.deleteDirectory;
import static org.onosproject.yangutils.utils.UtilConstants.EVENT_STRING;
import static org.onosproject.yangutils.utils.UtilConstants.OP_PARAM;
import static org.onosproject.yangutils.utils.UtilConstants.PERIOD;
import static org.onosproject.yangutils.utils.io.impl.YangIoUtils.getCapitalCase;
import static org.osgi.framework.FrameworkUtil.getBundle;


/**
 * Represent YANG schema registry. Yang schema registry provides interface to an application to register its YANG schema
 * with YMS. It provides YANG schema nodes to YDT, YNB and YSB.
 */
public class DefaultYangSchemaRegistry implements YangSchemaRegistry {

    private static final String SYSTEM = &quot;/system/&quot;;
    private static final String MAVEN = &quot;mvn:&quot;;
    private static final String HYPHEN = &quot;-&quot;;
    private static final String DELIMITER = &quot;.&quot;;
    private static final String SERVICE = &quot;Service&quot;;
    private static final String SER = &quot;.ser&quot;;
    private static final String JAR = &quot;.jar&quot;;
    private static final String YANG = &quot;.yang&quot;;
    private static final String USER_DIRECTORY = &quot;user.dir&quot;;
<span class="fc" id="L69">    private static final String SLASH = File.separator;</span>

<span class="fc" id="L71">    private static final Logger log = LoggerFactory.getLogger(DefaultYangSchemaRegistry.class);</span>

    /**
     * Map for storing app objects.
     */
    private ConcurrentMap&lt;String, YsrRegisteredAppContext&gt; appObjectStore;

    /**
     * Map for storing YANG schema nodes.
     */
    private ConcurrentMap&lt;String, YsrRegisteredAppContext&gt; yangSchemaStore;

    /**
     * Map for storing YANG schema nodes with respect to root's generated interface file name.
     */
    private ConcurrentMap&lt;String, YsrRegisteredAppContext&gt; yangSchemaStoreForRootInterface;

    /**
     * Map for storing YANG schema nodes root's generated op param file name.
     */
    private ConcurrentMap&lt;String, YsrRegisteredAppContext&gt; yangSchemaStoreForRootOpParam;

    /**
     * Map for storing YANG schema nodes with respect to notifications.
     */
    private ConcurrentMap&lt;String, YsrRegisteredAppContext&gt; yangSchemaNotificationStore;

    /**
     * Context of application which is registering with YMS.
     */
    private YsrRegisteredAppContext ysrRegisteredAppContext;

    /**
     * Creates an instance of YANG schema registry.
     */
<span class="fc" id="L106">    public DefaultYangSchemaRegistry() {</span>
<span class="fc" id="L107">        appObjectStore = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L108">        yangSchemaStore = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L109">        yangSchemaStoreForRootInterface = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L110">        yangSchemaStoreForRootOpParam = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L111">        yangSchemaNotificationStore = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L112">    }</span>

    /**
     * Returns app object store.
     *
     * @return app object store
     */
    private ConcurrentMap&lt;String, YsrRegisteredAppContext&gt; getAppObjectStore() {
<span class="fc" id="L120">        return appObjectStore;</span>
    }

    /**
     * Returns schema store.
     *
     * @return schema store
     */
    public ConcurrentMap&lt;String, YsrRegisteredAppContext&gt; getYangSchemaStore() {
<span class="fc" id="L129">        return yangSchemaStore;</span>
    }

    /**
     * Returns schema store.
     *
     * @return schema store
     */
    private ConcurrentMap&lt;String, YsrRegisteredAppContext&gt; getYangSchemaStoreForRootInterface() {
<span class="fc" id="L138">        return yangSchemaStoreForRootInterface;</span>
    }

    /**
     * Returns schema store.
     *
     * @return schema store
     */
    private ConcurrentMap&lt;String, YsrRegisteredAppContext&gt; getYangSchemaStoreForRootOpParam() {
<span class="fc" id="L147">        return yangSchemaStoreForRootOpParam;</span>
    }

    /**
     * Returns schema notification store.
     *
     * @return schema notification store
     */
    private ConcurrentMap&lt;String, YsrRegisteredAppContext&gt; getYangSchemaNotificationStore() {
<span class="fc" id="L156">        return yangSchemaNotificationStore;</span>
    }

    @Override
    public void registerApplication(Object appObject, Class&lt;?&gt; serviceClass) {

<span class="nc" id="L162">        BundleContext bundleContext = getBundle(serviceClass).getBundleContext();</span>
<span class="nc" id="L163">        String jarPath = getJarPathFromBundleLocation(bundleContext.getBundle().getLocation(),</span>
<span class="nc" id="L164">                                                      bundleContext.getProperty(USER_DIRECTORY));</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">        if (!getAppObjectStore().containsKey(serviceClass.getName())) {</span>
<span class="nc" id="L166">            List&lt;YangSchemaNode&gt; curNodes = processJarParsingOperations(jarPath, serviceClass.getSimpleName());</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">            for (YangSchemaNode schemaNode : curNodes) {</span>
<span class="nc" id="L168">                processApplicationContext(schemaNode, appObject);</span>
<span class="nc" id="L169">            }</span>
<span class="nc" id="L170">            ysrRegisteredAppContext().jarPath(jarPath);</span>
            //Store the YANG file handles.
<span class="nc" id="L172">            updateYangFileSet(jarPath);</span>
        }
<span class="nc" id="L174">    }</span>

    @Override
    public void unRegisterApplication(Object managerObject, Class&lt;?&gt; serviceClass) {

<span class="pc bpc" id="L179" title="1 of 2 branches missed.">        if (getAppObjectStore().containsKey(serviceClass.getName())) {</span>
<span class="fc" id="L180">            YsrRegisteredAppContext curContext = getAppObjectStore().get(serviceClass.getName());</span>
<span class="fc" id="L181">            YangSchemaNode curNode = curContext.curNode();</span>
<span class="fc" id="L182">            String appName = curNode.getJavaPackage() + PERIOD +</span>
<span class="fc" id="L183">                    getCapitalCase(curNode.getJavaClassNameOrBuiltInType());</span>
            //Delete all the generated ysr information in application's package.
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">            if (curContext.jarPath() != null) {</span>
<span class="nc" id="L186">                File jarPath = new File(curContext.jarPath());</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">                if (jarPath.exists()) {</span>
                    try {
<span class="nc" id="L189">                        deleteDirectory(new File(curContext.jarPath()));</span>
<span class="nc" id="L190">                    } catch (IOException e) {</span>
<span class="nc" id="L191">                        log.error(&quot;failed to delete ysr resources for &quot; + serviceClass.getName());</span>
<span class="nc" id="L192">                        e.printStackTrace();</span>
<span class="nc" id="L193">                    }</span>
                }
            }
            //Remove entry from maps.
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">            if (getYangSchemaStore().containsKey(curNode.getName())) {</span>
<span class="fc" id="L198">                removeSchemaNode(curNode);</span>
            }
            //Remove from notification store.
<span class="fc" id="L201">            if (getYangSchemaNotificationStore()</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">                    .containsKey(appName.toLowerCase() + PERIOD +</span>
<span class="fc" id="L203">                                         getCapitalCase(curNode.getJavaClassNameOrBuiltInType() + EVENT_STRING))) {</span>
<span class="fc" id="L204">                getYangSchemaNotificationStore()</span>
<span class="fc" id="L205">                        .remove(appName.toLowerCase() + PERIOD +</span>
<span class="fc" id="L206">                                        getCapitalCase(curNode.getJavaClassNameOrBuiltInType() + EVENT_STRING));</span>
            }
            //Remove from op param store.
<span class="fc" id="L209">            if (getYangSchemaStoreForRootOpParam()</span>
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">                    .containsKey(appName + OP_PARAM)) {</span>
<span class="fc" id="L211">                getYangSchemaStoreForRootOpParam()</span>
<span class="fc" id="L212">                        .remove(appName + OP_PARAM);</span>
            }
            //Remove from root interface store.
<span class="fc" id="L215">            if (getYangSchemaStoreForRootInterface()</span>
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">                    .containsKey(appName)) {</span>
<span class="fc" id="L217">                getYangSchemaStoreForRootInterface().remove(appName);</span>
            }
<span class="fc" id="L219">            getAppObjectStore().remove(serviceClass.getName());</span>
<span class="fc" id="L220">            log.info(&quot;YSR: service &quot; + serviceClass.getSimpleName() + &quot; is unregistered.&quot;);</span>
        }
<span class="fc" id="L222">    }</span>

    @Override
    public Object getRegisteredApplication(YangSchemaNode schemaNode) {
<span class="fc bfc" id="L226" title="All 2 branches covered.">        if (schemaNode != null) {</span>
<span class="fc" id="L227">            String name = schemaNode.getJavaPackage() + PERIOD +</span>
<span class="fc" id="L228">                    getCapitalCase(schemaNode.getJavaClassNameOrBuiltInType());</span>
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">            if (getYangSchemaStoreForRootInterface().containsKey(name)) {</span>
<span class="fc" id="L230">                return getYangSchemaStoreForRootInterface().get(name).appObject();</span>
            }
<span class="nc" id="L232">            log.error(&quot;YSR: &quot; + name + &quot; not found.&quot;);</span>
        }
<span class="fc" id="L234">        return null;</span>
    }

    @Override
    public YangSchemaNode getYangSchemaNodeUsingSchemaName(String schemaName) {
<span class="fc bfc" id="L239" title="All 2 branches covered.">        if (getYangSchemaStore().containsKey(schemaName)) {</span>
<span class="fc" id="L240">            return getSchemaNodeUsingSchemaNameWithRev(schemaName);</span>
        }
<span class="fc" id="L242">        log.error(&quot;YSR: &quot; + schemaName + &quot; not found.&quot;);</span>
<span class="fc" id="L243">        return null;</span>
    }

    @Override
    public YangSchemaNode getYangSchemaNodeUsingAppName(String appName) {
<span class="fc bfc" id="L248" title="All 2 branches covered.">        if (getAppObjectStore().containsKey(appName)) {</span>
<span class="fc" id="L249">            return getAppObjectStore().get(appName).curNode();</span>
        }
<span class="fc" id="L251">        log.error(&quot;YSR: &quot; + appName + &quot; not found.&quot;);</span>
<span class="fc" id="L252">        return null;</span>
    }

    @Override
    public YangSchemaNode getYangSchemaNodeUsingGeneratedRootNodeInterfaceFileName(String rootInterfaceFileName) {
<span class="fc bfc" id="L257" title="All 2 branches covered.">        if (getYangSchemaStoreForRootInterface().containsKey(rootInterfaceFileName)) {</span>
<span class="fc" id="L258">            return getYangSchemaStoreForRootInterface().get(rootInterfaceFileName).curNode();</span>
        }
<span class="fc" id="L260">        log.error(&quot;YSR: &quot; + rootInterfaceFileName + &quot; not found.&quot;);</span>
<span class="fc" id="L261">        return null;</span>
    }

    @Override
    public YangSchemaNode getYangSchemaNodeUsingGeneratedRootNodeOpPramFileName(String rootOpParamFileName) {
<span class="fc bfc" id="L266" title="All 2 branches covered.">        if (getYangSchemaStoreForRootOpParam().containsKey(rootOpParamFileName)) {</span>
<span class="fc" id="L267">            return getYangSchemaStoreForRootOpParam().get(rootOpParamFileName).curNode();</span>
        }
<span class="fc" id="L269">        log.error(&quot;YSR: &quot; + rootOpParamFileName + &quot; not found.&quot;);</span>
<span class="fc" id="L270">        return null;</span>
    }

    @Override
    public YangSchemaNode getRootYangSchemaNodeForNotification(String eventSubject) {
<span class="fc bfc" id="L275" title="All 2 branches covered.">        if (getYangSchemaNotificationStore().containsKey(eventSubject)) {</span>
<span class="fc" id="L276">            return getYangSchemaNotificationStore().get(eventSubject).curNode();</span>
        }
<span class="fc" id="L278">        log.error(&quot;YSR: &quot; + eventSubject + &quot; not found.&quot;);</span>
<span class="fc" id="L279">        return null;</span>
    }

    @Override
    public ConcurrentMap&lt;String, YsrRegisteredAppContext&gt; getNotificationSchemaMap() {
<span class="nc" id="L284">        return getYangSchemaNotificationStore();</span>
    }

    /**
     * Updates application object store.
     *
     * @param appName application name
     */
    private void updateAppObjectStore(String appName) {
<span class="fc" id="L293">        getAppObjectStore().put(appName, ysrRegisteredAppContext());</span>
<span class="fc" id="L294">    }</span>

    /**
     * Updates YANG schema object store.
     *
     * @param schemaNode application's schema node
     */
    private void updateYangSchemaStore(YangSchemaNode schemaNode) {
<span class="fc" id="L302">        addSchemaNodeUsingSchemaNameWithRev(schemaNode);</span>
<span class="fc" id="L303">    }</span>

    /**
     * Updates YANG schema notification object store.
     *
     * @param notificationName application's notification name
     */
    private void updateYangNotificationStore(String notificationName) {
<span class="fc" id="L311">        getYangSchemaNotificationStore().put(notificationName, ysrRegisteredAppContext());</span>
<span class="fc" id="L312">    }</span>

    /**
     * Updates YANG schema object store for root interface file name.
     *
     * @param rootInterfaceFileName name of generated interface file for root node
     */
    private void updateYangSchemaForRootInterfaceFileNameStore(String rootInterfaceFileName) {
<span class="fc" id="L320">        getYangSchemaStoreForRootInterface().put(rootInterfaceFileName, ysrRegisteredAppContext());</span>
<span class="fc" id="L321">    }</span>

    /**
     * Updates YANG schema object store  for root op param file name.
     *
     * @param rootOpParamFileName name of generated op param file for root node
     */
    private void updateYangSchemaForRootOpParamFileNameStore(String rootOpParamFileName) {
<span class="fc" id="L329">        getYangSchemaStoreForRootOpParam().put(rootOpParamFileName, ysrRegisteredAppContext());</span>
<span class="fc" id="L330">    }</span>

    /**
     * Updates the YANG file set.
     *
     * @param path YANG file path
     */
    private void updateYangFileSet(String path) {
<span class="nc" id="L338">        File yangFilePath = new File(path);</span>
<span class="nc" id="L339">        File[] fileArray = yangFilePath.listFiles();</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">        if (fileArray != null) {</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">            for (File curFile : fileArray) {</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">                if (curFile.getName().endsWith(YANG)) {</span>
<span class="nc" id="L343">                    ysrRegisteredAppContext().addToYangFileSet(curFile);</span>
                }
            }
        }
<span class="nc" id="L347">    }</span>

    /**
     * Process jar file for fetching YANG nodes.
     *
     * @param path    jar file path
     * @param appName application name
     * @return YANG schema nodes
     */
    private List&lt;YangSchemaNode&gt; processJarParsingOperations(String path, String appName) {
<span class="nc" id="L357">        File jarPath = new File(path + &quot;/yang&quot;);</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">        if (jarPath.exists()) {</span>
            try {
<span class="nc" id="L360">                deleteDirectory(jarPath);</span>
<span class="nc" id="L361">            } catch (IOException e) {</span>
<span class="nc" id="L362">                log.error(&quot;failed to delete old ysr resources for &quot; + appName);</span>
<span class="nc" id="L363">                e.printStackTrace();</span>
<span class="nc" id="L364">            }</span>
        }

        //Deserialize data model and get the YANG node set.
<span class="nc" id="L368">        return parseJarFile(path + JAR, path);</span>
    }

    /**
     * Process an application an updates the maps for YANG schema registry.
     *
     * @param appNode   application YANG schema nodes
     * @param appObject application's object
     */
    void processApplicationContext(YangSchemaNode appNode, Object appObject) {

        String appName;
        //Search the YANG node.
        //Create a new instance of ysr app context for each node.
<span class="fc" id="L382">        ysrRegisteredAppContext(new YsrRegisteredAppContext());</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">        if (appObject != null) {</span>
<span class="fc" id="L384">            ysrRegisteredAppContext().appObject(appObject);</span>
        }

<span class="fc" id="L387">        appName = appNode.getJavaPackage() + PERIOD +</span>
<span class="fc" id="L388">                getCapitalCase(appNode.getJavaClassNameOrBuiltInType());</span>
<span class="fc" id="L389">        ysrRegisteredAppContext().curNode(appNode);</span>
        //Updates maps wih app objects and schema nodes
<span class="fc" id="L391">        updateAppObjectStore(appName + SERVICE);</span>
<span class="fc" id="L392">        updateYangSchemaStore(appNode);</span>
<span class="fc" id="L393">        updateYangSchemaForRootInterfaceFileNameStore(appName);</span>
<span class="fc" id="L394">        updateYangSchemaForRootOpParamFileNameStore(appName + OP_PARAM);</span>
        //Checks if notification is present then update notification store map.
<span class="fc" id="L396">        String eventSubject = null;</span>
        try {
<span class="fc bfc" id="L398" title="All 2 branches covered.">            if (appNode.isNotificationPresent()) {</span>
<span class="fc" id="L399">                eventSubject = appName.toLowerCase() + PERIOD +</span>
<span class="fc" id="L400">                        getCapitalCase(appNode.getJavaClassNameOrBuiltInType()) + EVENT_STRING;</span>
            }
<span class="nc" id="L402">        } catch (DataModelException e) {</span>
<span class="nc" id="L403">            e.printStackTrace();</span>
<span class="fc" id="L404">        }</span>
<span class="fc bfc" id="L405" title="All 2 branches covered.">        if (eventSubject != null) {</span>
<span class="fc" id="L406">            updateYangNotificationStore(eventSubject);</span>
        }
<span class="fc" id="L408">        log.info(&quot;YSR: successfully registered this application &quot; + appName + SERVICE);</span>

<span class="fc" id="L410">    }</span>

    /**
     * Parses jar file and returns list of serialized file names.
     *
     * @param jarFile   jar file to be parsed
     * @param directory directory where to search
     * @return list of serialized files
     */
    private List&lt;YangSchemaNode&gt; parseJarFile(String jarFile, String directory) {

<span class="nc" id="L421">        List&lt;YangSchemaNode&gt; nodes = new ArrayList&lt;&gt;();</span>
        try {
<span class="nc" id="L423">            JarFile jar = new JarFile(jarFile);</span>
<span class="nc" id="L424">            Enumeration&lt;?&gt; enumEntries = jar.entries();</span>

<span class="nc bnc" id="L426" title="All 2 branches missed.">            while (enumEntries.hasMoreElements()) {</span>
<span class="nc" id="L427">                JarEntry file = (JarEntry) enumEntries.nextElement();</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">                if (file.getName().endsWith(SER)) {</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">                    if (file.getName().contains(SLASH)) {</span>
<span class="nc" id="L430">                        String[] strArray = file.getName().split(SLASH);</span>
<span class="nc" id="L431">                        String tempPath = &quot;&quot;;</span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">                        for (int i = 0; i &lt; strArray.length - 1; i++) {</span>
<span class="nc" id="L433">                            tempPath = SLASH + tempPath + SLASH + strArray[i];</span>
                        }
<span class="nc" id="L435">                        File dir = new File(directory + tempPath);</span>
<span class="nc" id="L436">                        dir.mkdirs();</span>
                    }
<span class="nc" id="L438">                    File serializedFile = new File(directory + SLASH + file.getName());</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">                    if (file.isDirectory()) {</span>
<span class="nc" id="L440">                        serializedFile.mkdirs();</span>
<span class="nc" id="L441">                        continue;</span>
                    }
<span class="nc" id="L443">                    InputStream inputStream = jar.getInputStream(file);</span>

<span class="nc" id="L445">                    FileOutputStream fileOutputStream = new FileOutputStream(serializedFile);</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">                    while (inputStream.available() &gt; 0) {</span>
<span class="nc" id="L447">                        fileOutputStream.write(inputStream.read());</span>
                    }
<span class="nc" id="L449">                    fileOutputStream.close();</span>
<span class="nc" id="L450">                    inputStream.close();</span>
<span class="nc" id="L451">                    nodes.addAll(deSerializeDataModel(serializedFile.toString()));</span>
                }
<span class="nc" id="L453">            }</span>
<span class="nc" id="L454">            jar.close();</span>
<span class="nc" id="L455">        } catch (IOException e) {</span>
<span class="nc" id="L456">            log.error(&quot;YSR: failed to fetch yang nodes from jar file for application &quot; +</span>
<span class="nc" id="L457">                              ysrRegisteredAppContext().appObject());</span>
<span class="nc" id="L458">            e.printStackTrace();</span>
<span class="nc" id="L459">        }</span>
<span class="nc" id="L460">        return nodes;</span>
    }


    /**
     * Returns jar path from bundle mvnLocationPath.
     *
     * @param mvnLocationPath mvnLocationPath of bundle
     * @return path of jar
     */
    private String getJarPathFromBundleLocation(String mvnLocationPath, String currentDirectory) {
<span class="nc" id="L471">        String path = currentDirectory + SYSTEM;</span>
<span class="nc" id="L472">        String[] strArray = mvnLocationPath.split(MAVEN);</span>
<span class="nc" id="L473">        String[] split = strArray[1].split(File.separator);</span>
<span class="nc" id="L474">        String[] groupId = split[0].split(Pattern.quote(DELIMITER));</span>

<span class="nc" id="L476">        path = path + groupId[0] + SLASH + groupId[1] + SLASH + split[1] +</span>
                SLASH + split[2] + SLASH + split[1] + HYPHEN + split[2];
<span class="nc" id="L478">        return path;</span>
    }

    /**
     * Returns de-serializes YANG data-model nodes.
     *
     * @param serializedFileInfo serialized File Info
     * @return de-serializes YANG data-model nodes
     */
    Set&lt;YangSchemaNode&gt; deSerializeDataModel(String serializedFileInfo) {

<span class="fc" id="L489">        Set&lt;YangSchemaNode&gt; nodes = new HashSet&lt;&gt;();</span>
        try {
<span class="fc" id="L491">            FileInputStream fileInputStream = new FileInputStream(serializedFileInfo);</span>
<span class="fc" id="L492">            ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);</span>
<span class="fc" id="L493">            nodes = (Set&lt;YangSchemaNode&gt;) objectInputStream.readObject();</span>
<span class="fc" id="L494">            objectInputStream.close();</span>
<span class="fc" id="L495">            fileInputStream.close();</span>
<span class="nc" id="L496">        } catch (IOException | ClassNotFoundException e) {</span>
<span class="nc" id="L497">            e.printStackTrace();</span>
<span class="nc" id="L498">            log.error(serializedFileInfo + &quot; not found.&quot;);</span>
<span class="fc" id="L499">        }</span>

<span class="fc" id="L501">        return nodes;</span>
    }

    /**
     * Returns ysr app context.
     *
     * @return ysr app context
     */
    private YsrRegisteredAppContext ysrRegisteredAppContext() {
<span class="fc" id="L510">        return ysrRegisteredAppContext;</span>
    }

    /**
     * Sets ysr app context.
     *
     * @param ysrRegisteredAppContext ysr app context
     */
    void ysrRegisteredAppContext(YsrRegisteredAppContext ysrRegisteredAppContext) {
<span class="fc" id="L519">        this.ysrRegisteredAppContext = ysrRegisteredAppContext;</span>
<span class="fc" id="L520">    }</span>

    /**
     * Returns schema node based on the revision.
     *
     * @param name name of the schema node
     * @return schema node based on the revision.
     */
    private YangSchemaNode getSchemaNodeUsingSchemaNameWithRev(String name) {
        YsrRegisteredAppContext appContext;
        YangSchemaNode schemaNode;
<span class="pc bpc" id="L531" title="1 of 2 branches missed.">        if (name.contains(&quot;@&quot;)) {</span>
<span class="nc" id="L532">            String[] revArray = name.split(&quot;@&quot;);</span>
<span class="nc" id="L533">            appContext = getYangSchemaStore().get(revArray[0]);</span>
<span class="nc" id="L534">            schemaNode = appContext.getSchemaNodeForRevisionStore(name);</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">            if (schemaNode != null) {</span>
<span class="nc" id="L536">                return schemaNode;</span>
            }
<span class="nc" id="L538">            return appContext.curNode();</span>
        }
<span class="fc" id="L540">        appContext = getYangSchemaStore().get(name);</span>
<span class="pc bpc" id="L541" title="1 of 2 branches missed.">        if (appContext != null) {</span>
<span class="fc" id="L542">            return appContext.curNode();</span>
        }
<span class="nc" id="L544">        return null;</span>
    }

    /**
     * Adds schema node when different revision of node has received.
     *
     * @param schemaNode schema node
     */
    private void addSchemaNodeUsingSchemaNameWithRev(YangSchemaNode schemaNode) {

<span class="fc" id="L554">        String date = getDateInStringFormat(schemaNode);</span>
<span class="fc" id="L555">        String name = schemaNode.getName();</span>
<span class="pc bpc" id="L556" title="1 of 2 branches missed.">        if (!date.equals(&quot;&quot;)) {</span>
<span class="fc" id="L557">            name = name + &quot;@&quot; + date;</span>
        }
        //check if already present.
<span class="fc" id="L560">        YangRevision revision = ((YangNode) schemaNode).getRevision();</span>
<span class="fc bfc" id="L561" title="All 2 branches covered.">        if (!getYangSchemaStore().containsKey(schemaNode.getName())) {</span>
<span class="fc" id="L562">            ysrRegisteredAppContext().curNode(schemaNode);</span>
            //if revision is not present no need to add in revision store.
<span class="pc bpc" id="L564" title="1 of 2 branches missed.">            if (revision != null) {</span>
<span class="fc" id="L565">                ysrRegisteredAppContext().addSchemaNodeWithRevisionStore(name, schemaNode);</span>
            }
<span class="fc" id="L567">            getYangSchemaStore().put(schemaNode.getName(), ysrRegisteredAppContext());</span>
        } else {
<span class="fc" id="L569">            YsrRegisteredAppContext appContext = getYangSchemaStore().get(schemaNode.getName());</span>
            //check if old node has revision
<span class="fc" id="L571">            YangRevision oldDate = ((YangNode) appContext.curNode()).getRevision();</span>
            //check if current revision and new revision are same or different.

<span class="pc bpc" id="L574" title="3 of 4 branches missed.">            if (oldDate == null &amp;&amp; revision != null) {</span>
                // if new revision is not null but old one is then we need to add new node to store.
<span class="nc" id="L576">                appContext.addSchemaNodeWithRevisionStore(name, schemaNode);</span>
<span class="pc bpc" id="L577" title="2 of 4 branches missed.">            } else if (oldDate != null &amp;&amp; revision == null) {</span>
                // if new revision is null but old one is not then we need to add update the current node.
<span class="nc" id="L579">                appContext.curNode(schemaNode);</span>
<span class="pc bpc" id="L580" title="1 of 2 branches missed.">            } else if (oldDate != null) {</span>
                // if new revision is and old both are not null then we need to add update the current node.
                //if old date is before the new date the need to update node.
<span class="pc bpc" id="L583" title="1 of 2 branches missed.">                if (oldDate.getRevDate().compareTo(revision.getRevDate()) &lt; 0) {</span>
<span class="nc" id="L584">                    appContext.curNode(schemaNode);</span>
<span class="pc bpc" id="L585" title="1 of 2 branches missed.">                } else if (oldDate.getRevDate().compareTo(revision.getRevDate()) &gt; 0) {</span>
                    //if old date is after the new date the need to update map.
<span class="nc" id="L587">                    appContext.addSchemaNodeWithRevisionStore(name, schemaNode);</span>
                }
            } else {
                // do nothing. because curNode is already the latest node and
                // map does not need any update.
            }
        }
<span class="fc" id="L594">    }</span>

    /**
     * Returns date in string format.
     *
     * @param schemaNode schema node
     * @return date in string format.
     */
    private String getDateInStringFormat(YangSchemaNode schemaNode) {
<span class="pc bpc" id="L603" title="1 of 2 branches missed.">        if (schemaNode != null) {</span>
<span class="pc bpc" id="L604" title="1 of 2 branches missed.">            if (((YangNode) schemaNode).getRevision() != null) {</span>
<span class="fc" id="L605">                return new SimpleDateFormat(&quot;yyyy-mm-dd&quot;)</span>
<span class="fc" id="L606">                        .format(((YangNode) schemaNode).getRevision().getRevDate());</span>
            }
        }
<span class="nc" id="L609">        return &quot;&quot;;</span>
    }

    /**
     * Removes schema node from schema map.
     *
     * @param schemaNode schema node
     */
    private void removeSchemaNode(YangSchemaNode schemaNode) {
<span class="fc" id="L618">        YsrRegisteredAppContext appContext = getYangSchemaStore().get(schemaNode.getName());</span>
<span class="pc bpc" id="L619" title="1 of 2 branches missed.">        if (((YangNode) appContext.curNode()).getRevision() != null) {</span>
<span class="pc bpc" id="L620" title="1 of 2 branches missed.">            if (!appContext.getYangSchemaNodeForRevisionStore().isEmpty()) {</span>
<span class="fc" id="L621">                handleSchemaNodeWhenRevEntryExists(appContext, schemaNode.getName());</span>
            }
        } else {
<span class="nc bnc" id="L624" title="All 2 branches missed.">            if (appContext.getYangSchemaNodeForRevisionStore().isEmpty()) {</span>
<span class="nc" id="L625">                getYangSchemaStore().remove(schemaNode.getName());</span>
            } else {
<span class="nc" id="L627">                handleSchemaNodeWhenRevEntryExists(appContext, schemaNode.getName());</span>
            }
        }
<span class="fc" id="L630">    }</span>

    /**
     * Removes and replace schema node with latest revision schema.
     *
     * @param appContext application context
     * @param name       name of schema node
     */
    private void handleSchemaNodeWhenRevEntryExists(YsrRegisteredAppContext appContext, String name) {
<span class="fc" id="L639">        ConcurrentMap&lt;String, YangSchemaNode&gt; schemaRevStore = appContext.getYangSchemaNodeForRevisionStore();</span>
<span class="fc" id="L640">        YangSchemaNode approvedNode = null;</span>
<span class="pc bpc" id="L641" title="1 of 2 branches missed.">        if (schemaRevStore.size() == 1) {</span>
<span class="fc" id="L642">            getYangSchemaStore().remove(name);</span>
        } else {
<span class="nc" id="L644">            Iterator&lt;YangSchemaNode&gt; iterator = schemaRevStore.values().iterator();</span>
<span class="nc" id="L645">            YangNode prevNode = (YangNode) iterator.next();</span>
            YangRevision preRev;
            YangNode nextNode;
            YangRevision nextRev;
<span class="nc bnc" id="L649" title="All 2 branches missed.">            while (iterator.hasNext()) {</span>
<span class="nc" id="L650">                nextNode = (YangNode) iterator.next();</span>
<span class="nc" id="L651">                preRev = prevNode.getRevision();</span>
<span class="nc" id="L652">                nextRev = nextNode.getRevision();</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">                if (preRev.getRevDate().compareTo(nextRev.getRevDate()) &gt; 0) {</span>
<span class="nc" id="L654">                    approvedNode = prevNode;</span>
                } else {
<span class="nc" id="L656">                    approvedNode = nextNode;</span>
                }
<span class="nc" id="L658">                prevNode = (YangNode) approvedNode;</span>
            }
<span class="nc bnc" id="L660" title="All 2 branches missed.">            if (approvedNode != null) {</span>
<span class="nc" id="L661">                appContext.curNode(approvedNode);</span>
<span class="nc" id="L662">                name = approvedNode.getName() + &quot;@&quot; +</span>
<span class="nc" id="L663">                        getDateInStringFormat(approvedNode);</span>
<span class="nc" id="L664">                schemaRevStore.remove(name);</span>
            }
        }

<span class="fc" id="L668">    }</span>

    /**
     * Verifies if the manager object is already registered with notification handler.
     *
     * @param serviceClass service class
     * @return true if the manager object is already registered with notification handler.
     */
    public boolean verifyNotificationObject(Class&lt;?&gt; serviceClass) {

<span class="nc bnc" id="L678" title="All 2 branches missed.">        if (getAppObjectStore().containsKey(serviceClass.getName())) {</span>
<span class="nc" id="L679">            YangSchemaNode schemaNode = getYangSchemaNodeUsingAppName(serviceClass.getName());</span>

<span class="nc" id="L681">            String name = (schemaNode.getJavaPackage() + PERIOD +</span>
<span class="nc" id="L682">                    schemaNode.getJavaClassNameOrBuiltInType() + PERIOD).toLowerCase()</span>
<span class="nc" id="L683">                    + getCapitalCase(schemaNode.getJavaClassNameOrBuiltInType()) + EVENT_STRING;</span>

<span class="nc bnc" id="L685" title="All 2 branches missed.">            if (getNotificationSchemaMap().containsKey(name)) {</span>
<span class="nc bnc" id="L686" title="All 2 branches missed.">                if (!getNotificationSchemaMap().get(name).isNotificationRegistered()) {</span>
<span class="nc" id="L687">                    getNotificationSchemaMap().get(name).setNotificationRegistered(true);</span>
<span class="nc" id="L688">                    return true;</span>
                }
            }
        }
<span class="nc" id="L692">        return false;</span>

    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>